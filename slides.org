#+subtitle: CS 350
#+AUTHOR: Dr. Joseph Eremondi
#+DATE: Last updated: \today{}



#+OPTIONS: toc:nil H:2 num:t TODO:nil eval:yes

#+BEAMER_HEADER: \usepackage[sfdefault]{atkinson} %% Option 'sfdefault' if the base
#+BEAMER_HEADER: \usepackage{FiraMono}
#+BEAMER_HEADER: \usepackage[T1]{fontenc}




#+EXPORT_FILE_NAME: slides_all.pdf
#+startup: beamer
#+LaTeX_CLASS:beamer
#+LaTeX_CLASS_OPTIONS: [bigger]
#+LaTeX_CLASS_OPTIONS: [dvipsnames]
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)
#+beamer: \beamerdefaultoverlayspecification{<+->}


# -*- org-latex-packages-alist: nil; -*-

# #+BEAMER_HEADER: \renewcommand{\pageword}{}


# #+BEAMER_HEADER: \usetheme[customfont,nofooter]{pureminimalistic}
#+BEAMER_HEADER: \usetheme{moloch}
# #+BEAMER_HEADER:\definecolor{textcolor}{RGB}{0, 0, 0}
#+BEAMER_HEADER:\definecolor{title}{RGB}{2, 71, 49}
# #+BEAMER_HEADER:\renewcommand{\beamertextcolor}{textcolor}
# #+BEAMER_HEADER:\renewcommand{\beamerfootertextcolor}{footercolor}
# #+BEAMER_HEADER:\renewcommand{\beamertitlecolor}{title}
# #+BEAMER_HEADER:\setbeamertemplate{frametitle}{\\setbeamercolor{alerted text}{fg=black}
#+BEAMER_HEADER: \setbeamercolor{alerted text}{fg=black}
#+BEAMER_HEADER: \setbeamerfont{alerted text}{series=\bfseries}
#+BEAMER_HEADER: \newcommand{\colored}[2]{{\color{#1} #2}}

#+BEAMER_HEADER: \usepackage[utf8]{inputenc}
#+BEAMER_HEADER: \usepackage[libertine]{newtxmath}
#+BEAMER_HEADER: \DeclareUnicodeCharacter{03BB}{${\lambda}$}
#+BEAMER_HEADER: \usepackage{semantic}
#+BEAMER_HEADER: \usepackage{stmaryrd}
#+BEAMER_HEADER: \mathlig{=>}{\Rightarrow}
#+BEAMER_HEADER: \definecolor{LightGray}{gray}{0.9}
#+BEAMER_HEADER: \usepackage[outputdir=pdf]{minted}
#+BEAMER_HEADER: \usepackage{etoolbox}
#+BEAMER_HEADER: \usepackage{hyphenat}
#+BEAMER_HEADER: \AtBeginEnvironment{minted}{\pause} \setminted[racket]{escapeinside=||,bgcolor=LightGray,beameroverlays=true,baselinestretch=1.2,fontsize=\scriptsize}

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides001-intro.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil

** Course Overview
*** Course Objectives
To learn:
- Functional programming
  + Recursion
  + Immutable data
  + Programming by cases
  + Higher-order functions
- How to write your own programming language
  + Parsing/Abstract Syntax
  + Desugaring
  + Evaluation

- _To change how you /think/ about programming_
*** Textbook
- /Programming Languages: Application and Interpretation/, 2nd edition, by Shriram Krishnamurthi
  + aka PLAI
  + Freely avaliable online, pdf in UR Courses
- 3rd edition also available
  + Optional additional reference
  + Similar content but very different approach
  + When in doubt, we're following the 2nd edition

*** Course Communication
- Everything on URCourses
  + Announcements
  + Assignments and Handin
  + Textbook, Slides, Videos
  + Email
  + Discussion Forum

- Do NOT ask programming/conceptual questions by email
  + Use the discussion forum
  + If you're wondering, others are too
  + EXCEPTION: when you can't ask your question without revealing
    your solution to the assignment

*** Grading Scheme
  + 25% assignments
  + 25% midterm
    - In-class
    - Thursday, July 25
  + 50% final
    - Aug 19
    - 2pm-5pm
    - This room
*** Assignments
- Six weekly assignments
- Due Tuesday at noon (11:59am)
  + No extensions
  + Lowest grade dropped
- Submitted over UR Courses
*** Assignments (ctd.)
- Mostly programming
  + Some conceptual questions
- Score based on running tests
  + Some public (included in assignment)
  + Some private (only known by me)
  + Code doesn't run $->$ no marks
- Some points for style/documentation/etc.
  +  Sample based marking
*** Attendance
- Attendance is mandatory but unenforced
  + Lecture contents is fair game for exams
- Lectures will contain walk-throughs of code
  and problem solving examples
- This is NOT a memorization-focused class
- I'll do my best to post slides and example code from lectures
  + But ultimately it's your responsibility to catch up on missed material
*** Office Hours :
- Mon 2:30-3:45pm
- Mon 4:30-5:15pm
- Wed 11:00am-11:45am
- Thurs 2:30-3:45pm
- RIC 317
  + Take the elevator to 3rd floor, then go straight across
*** LLM Policy
**** Use of ChatGPT, GitHub Copilot, or any other Large Language Model or Generative AI is forbidden when completing the assignments for this class
- Considered a violation of Academic Integrity
**** ChatGPT has trouble with Racket/plait
- Don't expect sympathy if you copy/paste code from an LLM that doesn't work
**** Don't set yourself up for failure on the exams
- Doing the assignments is the best way to study
** Motivation: Functional Programming
*** Programming in This Class
- In plait
  + i.e., "PLAI-typed"
- Plait is
  + a programming language
  + a library for the Racket programming language
- We'll learn more why this distinction is fuzzy
*** What is Racket
- A programming language for writing programming languages
- LISP-like
  - parentheses ~(((((((((())))))))))~
  - functions are values just like anything else
- Immutable: once a variable has a value, it never changes
  + Racket does let you mutate variables,
    but those parts of the language are *forbidden* in this class
    - Unless otherwise specified

*** Will I Ever Use Racket in Industry?
**** \qquad
*****   \centering\huge _No_
*****   \centering (probably)
*** Future Proofing
- Don't know what you'll use in industry in 10 years
  + If you know how languages work, you can learn /any/ language quickly
  + Racket is effective for learning how languages work

*** Language Trends (from Google Trends)

**** \colored{RoyalBlue}{Objective C} vs \colored{BrickRed}{Swift}
[[./img/objc_vs_swift.png]]

**** \colored{RoyalBlue}{C++} vs \colored{BrickRed}{Python}
[[./img/cpp_vs_python.png]]
*** Syntax Vs Semantics
- Semantics
  + What a program /means/
  + How a program behaves
- Different syntaxes can have identical semantics
- _Course goal:_ Learning to see past syntax and understand a program
  as its semantics
- Racket looks very different from other languages
  + Expressions, not statements
  + Recursion, not loops
  + Parentheses & functions, not operators
- Changes how you think about programs

*** Seeing Past Syntax
 By the end of the course, you should be able to look at these programs and intuitively
 know that they're doing the same thing:

**** CPP
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+latex: {\scriptsize
  #+begin_src C :exports code
  int pow (int x, int y){
    int ret = 1;
    for (int i = 0; i < y; i++){
      ret *= x;
    }
    return ret;
  }
  #+end_src
#+latex: }

**** Racket
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+latex: {\scriptsize
#+begin_src racket :exports code
(define (pow x y)
  (if
    (<= y 0)
    0
    (* x (pow x (- y 1)))))
#+end_src
#+latex: }



*** Functional Programming Going Mainstream?
- We're seeing more languages adopt functional features
- Anonymous functions/closures (lambda)
  + Python, Ruby, JS, PHP, Swift, Go, Rust, etc.

  + Added to C++11

  + Added in Java 8
  + Most language have some form of ~map~ to apply a function to each element of a list

- Sum types
  + Also called variants, algebraic datatypes
  + Perfect for syntax trees
  + Now in Python, Typescript, C++ (~std::variant~), Java (sealed interfaces), Rust (enums)

- Learning these features in Racket will help if/when they show up in other languages in the future


** Motivation: Interpreters
    
*** Importance of Programming Languages
- Interpreter: (Code , input) $\hookrightarrow$ (Output , effects)
  + Effects: write to disk, display pixels, etc
- You interact with a compiler or interpreter every time you:
  + Write a program
  + Run a program
    - Python, JavaScript, JVM all use some kind of interpreter
    - The CPU is just an interpreter for machine code

*** Programming Languages Aren't Magic
- Understanding how languages are implemented can help you understand your code
  + Why is it slow/fast
  + How to prevent/properly handle errors
  + How to know that it's doing what you think it does

*** Domain Specific Languages :noexport:
- Small language for a particular kind of task

*** Is this a hard course?
**** Why interpreters are hard
- By the end if this course, you will be able to write a program that is
  powerful enough to simulate every other computer program that ever has or
  ever will be written

**** Why interpreters are easy
- It's just a bunch of tree traversals


*** Intro

**** Questions?
* Functional Programming 1: Recursion and Immutable Data
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides002-plait.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

*** Overview
- Topic: Functional Programming in Racket and plait
- Required Reading:
  + Plait tutorial (URCourses)
- Optional Reference
  + Plait videos, HtDP videos
** Programming in CS 350
*** All coding for this class uses:
- The Racket Programming Language
- The ~plait~ library for Racket
- The Dr. Racket editor
** Racket
*** What is Racket?
- Lisp-style language
  + ~((((((((Parentheses))))))))~
- Language for making languages

*** What is Dr. Racket?
- IDE for Racket
  - Syntax highlighting
  - Other useful features
- Read-Eval-Print-Loop (REPL)
  + Feedback when writing code
  + Can  evaluate expressions while you're writing your code
- Other editors are possible
  + ... but you're on your own if you have problems
  + see https://docs.racket-lang.org/guide/other-editors.html

** Plait
*** What is Plait?
****  "PLAI-typed"
**** Language defined in Racket
- Racket functions you can call
- Adds syntax to Racket
  + Declaring and pattern matching on data types
  + Type annotations for functions
- Minimal
  + Has what you need to write programming languages
  + Not much else
  + You can do a lot with very little

*** Plait features:

- Type inference
  + Every expression is typed
  + Don't have to write down the types
- Algebraic Data Types



*** Parentheses
- Racket programs are trees called "S-expressions"
- Parentheses give this tree structure
- Default: parentheses mean function call
  + Racket writes ~(f x)~, not ~f(x)~
- ~x~ is not the same as ~(x)~
  + ~x~ gets the value of the variable ~x~
  + ~(x)~ is calling a function named ~x~ with zero arguments

*** Numbers

****   
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:

#+name: plait-numbers
#+begin_src racket :exports both
;;!!appear!!
;;!!results!!
(+ 2 7)
(- 10 0.5)
(* 1/3 2/3)
(/ 1 1000000000000.0)
(max 10 20)
(modulo 10 3)
#+end_src

****    
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:
#+BEGIN_EXPORT latex
\onslide<1->
#+END_EXPORT
#+RESULTS: plait-numbers


*** Booleans

****   
:PROPERTIES:
:BEAMER_COL: 0.68
:BEAMER_ENV: block
:END:

#+name: plait-booleans
#+begin_src racket :exports both
;;!!appear!!
;;!!results!!
(= (+ 2 3) 5)
(> (/ 0 1) 1)
(zero? (- (+ 1 2) (+ 3 0)))
(and (< 1 2) (> 1 0))
(or (zero? 1) (even? 3))
#+end_src

****    
:PROPERTIES:
:BEAMER_COL: 0.28
:BEAMER_ENV: block
:END:
#+BEGIN_EXPORT latex
\onslide<1->
#+END_EXPORT
#+RESULTS: plait-booleans


        
***  Conditionals
- Conditionals are *expressions*, not statements
- Boolean changes what the expression *is*, not what it does
#+begin_src racket :exports both
(if (< 2 3) "hello" "goodbye")
(+ 3
  (if (= 2 (+ 1 1))
      3
      40))
#+end_src

***  Functions
- Calling a function replaces variable with concrete argument
#+begin_src racket :exports both
(define (addOne [x : Number]) : Number
  (+ x 1))
(addOne 10)
#+end_src

***  Functions
#+begin_src racket :exports both
(define (isRemainder [x : Number]
                     [y : Number]
                     [remainder : Number])
        : Boolean
  (= remainder (modulo x y)))
(isRemainder 10 3 1)
(isRemainder 10 4 1)
#+end_src

***  Functions (ctd.)
- General form:

#+begin_src racket :exports code
(define (functionName
         [argName : argType]
         ...
         [argNameN : argTypeN]) : returnType
  functionBody)
#+end_src
- Later in the course we'll see another way of defining functions

*** Symbols
- Special type in Racket
- Written with single quote ~'a~, ~'hello~, ~'foo~
- Like strings, but you don't ever traverse/concatenate/look inside
- Only relevant operation is comparison
  + ~(symbol=? 'a 'b)~
  + Compares pointers, so very fast




*** Intermediate definitions
- Can still define variables
  + Once they're given a value, never changes
  + Allows re-use
    - Only evaluated once, can use multiple times
#+begin_src  racket :noweb strip-export :exports both
(define (squaredSum [x : Number]
                    [y : Number]) : Number
  (let ([xy (+ x y)])
    (* xy xy)))
(squaredSum 1 2)
#+end_src

#+RESULTS:
#+begin_src racket
8
300000
#+end_src

*** Alternate Versions of Let
- ~let*~ : multiple definitions, later ones can refer to earlier ones
- 99% of the time this is what you want to use
  #+begin_src racket
    (let* ([x (+ 2 3)]
           [y (* x x)])
      (* y y))
  #+end_src


- ~letrec~ : multiple definitions that can all refer to each other
  + We'll see this later when we learn about lambdas
** Functional Thinking and Recursion

*** What Is Functional Programming?
- Functions in our program correspond to functions in math
  + Mapping from inputs to outputs
  + Same inputs always produce the same outputs
- Talk about what programs *are*, not what programs do
- Instead of changing variable values
  + We call functions with different arguments
- Instead of changing data structures
  + We decompose them, copy the parts, and reassemble them in new ways
  + Copying is implemented with pointers
    - Fast, memory efficient

*** Advantages of Functional Programming
- All program state is *explicit*
  + Easy to tell exactly what a function can change
  + No shared state between components
    - Other function can't change value without realizing
    - No data races for threading
- Programming is *declarative*
  + Structure of the problem guides structure of the solution
- Equational reasoning
  + In imperative languages, equals sign ~=~ is a LIE
    - Can write ~x = 3; x = 4;~, but ~3 != 4~
  + If have ~(define (f x) body)~, then for all ~y~,
    ~(f y)~ and ~body~ are interchangable
    - after replace ~x~ with ~y~ in ~body~
    - Easier to tell if your program is correct
    - Some optimizations easier
*** Disadvantages of Functional Programming
- None?
- Sometimes slower
  + Very hard to do without Garbage Collection
    - e.g. see Closures in Rust
  + Sometimes faster because you need fewer safety checks in your code
- Farther from what the CPU is actually doing
- Some algorithms are more concise with mutation
  + But lots aren't
*** How to design functional programs
**** 5 Step method:
1. Determine the *representation* of inputs and outputs
2. Write *examples* and tests
3. Create a *template* of the function
   - Depends on input/output types
   - Covers all cases
   - Possibly extracts fields, recursive calls, etc.
4. *Fill* in the holes in the template

5. *Run* tests

**** Further reference:
http://htdp.org, Matthew Flatt's Notes (URCourses)




*** Factorial - Representation
- $n! = 1 \times 2 \times \ldots n$
- Takes in a (natural) number, outputs a number
  #+begin_src racket
  (define (factorial [n : Number]) : Number
    (error 'factorial "TODO"))
  #+end_src


*** Factorial - Examples
  #+begin_src racket
   ;;!!appear!!

  (test (factorial 0) 1 )
  (test (factorial 1) 1 )
  (test (factorial 2) 2 )
  (test (factorial 3) 6 )
  (test (factorial 4) 24 )
  (test (factorial 5) 120 )
  #+end_src
- Notice the pattern?

*** Factorial - Template
- A natural number is either
  + Zero
  + One more than some other number
    - We call this the "successor", written "S" or "suc"
    - Probably want to use this in the solution
#+begin_src racket
(define (factorial [n : Number]) : Number
  (if (zero? n)
      (error 'zero "TODO")
      (let ([n-1 (- n 1)])
        (error 'suc "TODO"))
      ))
#+end_src


*** Factorial - Recursion
- Divide problem into base case and recursive cases
- Can use recursive calls to smaller arguments
- Build up solution in terms of solutions to smaller problems
#+begin_src racket
(define (factorial [n : Number]) : Number
  (if (zero? n)
      (error 'zero "TODO")
      (let*
          ([n-1 (- n 1)]
           [fn-1 (factorial n-1)])
          (error 'suc "TODO"))
      ))
#+end_src

*** Factorial - Filling holes
- Example gives the base case for 0
- Notice the pattern
  + Multiplying the first n numbers is the same as n times the first n-1 numbers
  + We get that from our recursive call
#+name: factorial-complete
#+begin_src racket
(define (factorial [n : Number]) : Number
  (if (zero? n)
      1
      (let*
          ([n-1 (- n 1)]
           [fn-1 (factorial n-1)])
          (* n fn-1))
      ))
#+end_src


*** Run Tests
#+begin_src racket :exports both :noweb strip-export
<<factorial-complete>>
(test (factorial 0) 1 )
(test (factorial 5) 120 )
#+end_src


*** Trust the Natural Recursion

- The magic key:
  + /Assume/ you have a solution already, but only for smaller arguments
  + Express solution for larger ones in terms of smaller ones
  + Like induction in math
- The shape of the data guided the shape of the solution
  + Zero had no sub-data, so there were no recursive calls
  + $suc\ n$ has one sub-value, namely $n$
    - One recursive call

*** Preconditions
- Note: types not quite precise enough
  + e.g. ~(factorial -1)~ or ~(factorial 1/2)~ loop forever
- Precondition: argument is a non-negative whole number
  + Can't express this in the code, so write in the comments
  + Aside: I research languages where you /can/ express this with types

*** Another Example: Exponentiation
+ Live coding in Dr. Racket



** Unbounded Data: Lists

*** Functional Linked Lists
- Every linked list is one of:
  + Empty (sometimes called ~nil~ or ~null~)
  + An element appended to the beginning of another list
- We call the operation of appending an element to a list ~cons~
  + Historical name, goes back to LISP days
- Cons does *not* change its input
  + Creates a new list whose tail is the old list

*** Lists in Racket
+ Multiple ways to write lists
+ ~'()~ is the empty list, can also write ~empty~
+ Extending lists:  ~(cons h t)~ creates list with element ~h~ appended to list ~t~
  - ~h~ and ~t~ for ~head~ and ~tail~
+ List literals, can write ~(list 1 2 3 4)~ or ~'(1 2 3 4)~
  - Shorthand for:
  - ~(cons 1 (cons 2 (cons 3 (cons 4 '()))))~
+ Lots more helper functions, see the documentation


*** Template for Lists
- Two cases: list is empty or cons
- Make a recursive call on tail of cons case
  #+begin_src racket
  (define (list-template
           [xs : (Listof Number)])
    (if (empty? xs)
        (error 'nil "TODO")
        (let ([h (first xs)]
              [t (rest xs)]
              [tRet (list-template t)])
          (error 'cons "TODO"))
        ))
  #+end_src

*** Example: Sum
#+begin_src racket :exports both
  (define (sum [xs : (Listof Number)])
    : Number
    (if (empty? xs)
        0
        (let* ([h (first xs)]
               [t (rest xs)]
               [tRet (sum t)])
          (+ h tRet))))
   (sum '())
   (sum '(1 2 3))
   (sum '(100 2 3))
#+end_src

#+RESULTS:
#+begin_src racket
0
6
#+end_src

*** Pattern Matching: Motivation
+ Recursive case: used "getter" function to get the sub-data in the recursive case
  - ~(- x 1)~ for numbers
  - ~first~ and ~rest~ for lists
+ Always want to have the sub-parts available
+ Don't want to apply getters on the wrong data
  - e.g. ~first '()~ will raise an error


*** Pattern Matching:


*** Example: Generating a Modified List
+ e.g. Increment each number in a list
  + Uses pattern matching
  + Shows how to create lists recursively
  #+begin_src racket :exports both
(define (increment [xs : (Listof Number)])
        : (Listof Number)
  (type-case (Listof Number) xs
    [empty
       empty]
    [(cons h t)
       (cons (+ h 1) (increment t))]))
(increment '(2 3 4))
  #+end_src



*** Parametric Polymorphism
+ Lists are a *parameterized type*
  - Only need to define once for the different element types
+ Many list functions are *polymorphic*
  - Work regardless of what type of elements there are
  - Types contain *type variables*, denoted with single quote ~'x~
    + Like symbols
  - Plait type inference figures out solutions for type variables when you call a function
  - E.g. ~first : ((Listof 'a) -> 'a)~
    + Input is list whose elements are some type ~'a~
    + Output has type ~'a~
    + e.g. ~first '(1 2 3)~ is a ~Number~, but ~first '(#t #f #t)~ is a Boolean
+ Later, this will be very useful for writing generic list operations

*** Example: List Concatenation
- We can combine two lists into a single list
- Polymorphic type
  + Works for list with any contents
  + We never do anything with the contents other than copy
  + This function is built into Plait as ~append~
    #+name: plait-concat-def
    #+begin_src racket :exports both
  (define (concat [xs : (Listof 'elem)]
                  [ys : (Listof 'elem)])
          : (Listof 'elem)
    (type-case (Listof 'elem) xs
      [empty
         ys]
      [(cons h t)
         (cons h (concat t ys))]))
    #+end_src

*** Example: List Concatenation (ctd.)
**** Example
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:
    #+name: plait-concat
    #+begin_src racket :exports both :noweb strip-export
  <<plait-concat-def>>
  ;;!!appear!!
  ;;!!results!!

  (concat '(1 2 3) '(4 5 6))
  (concat '("3" "5") '("0"))
  (concat '() '(#t))
  (concat '(#f) '())
    #+end_src

**** Results
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:
#+RESULTS: plait-concat


*** More Examples
- Demo: Dr. Racket (as time permits)
  + Duplicating each element of a list
  + "zipping" two lists together
  + Filtering out odd elements of a list


* Functional Programming 2: Defining Data Types
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides003-datatypes.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** Warmup: Pairs

*** Pairs: "AND" for types
-  ~(Number * Boolean)~
  + Cartesian product
    - "AND" for types
  + A value of this type contains a ~Number~ AND ~a Boolean~
  + Why is it infix? Who knows
    - Maybe to help distinguish it from multiplication
- Projections
  + Get the data from the pairs
#+begin_src racket :exports both
(define myPair : (Number * Boolean)
   (pair 2 #t))
(fst myPair) ;;Number
(snd myPair) ;;Boolean
#+end_src

#+RESULTS:
#+begin_src racket
2
#t
#+end_src
*** Pairs in General
- For any types ~'a~ and ~'b~ there is a type ~('a * 'b)~
- Build with ~pair : ('a 'b -> ('a * 'b))~
  + Takes one argument of each type, produces the pair
- Projections
  + ~fst : (('a * 'b) -> 'a)~
  + ~snd : (('a * 'b) -> 'b)~

** Algebraic Data Types

*** "OR" for types
- Pairs gave us "AND"
- What does "OR" look like for types?
  + ~(OR Number Boolean)~ should be the type of values that are either a number or a boolean
  + Want a tag so we can check which one it is
    - Called a "constructor"
    - not the same as Java/OOP constructor
- Saw some examples like this already
  + A number is zero OR one plus another number
  + A list is empty OR an element cons-ed to another list
- Racket lets us define our own types mixing AND and OR

*** First example

#+name: shape-defn
#+begin_src racket
(define-type Shape
  (Rectangle [length : Number]
             [width : Number])
  (Circle [radius : Number]))

(define tv (Rectangle 16 9))
(define loonie (Circle 1))
#+end_src
- ~Shape~ is a /datatype/
- It has two /constructors/, ~Rectangle~ and ~Circle~
  + i.e. a Shape is a circle or a rectangle
- ~Rectangle~ has two fields with type Number, ~length~ and ~width~
- ~Circle~ has one field with type Number

*** Creating values of a datatype
#+begin_src racket
(define-type Shape
  (Rectangle [length : Number]
             [width : Number])
  (Circle [radius : Number]))

(define tv (Rectangle 16 9))
(define loonie (Circle 1))
#+end_src
- We construct a Shape by calling a constructor
  + Doesn't *do* anything except package the data together
- A Shape either has two numbers OR one number
  + Depending on the tag
*** Auto-generated Functions
#+begin_src racket :noweb strip-export
<<shape-defn>>
(Rectangle? tv)
(Circle? tv)
(Rectangle-length tv)
;; (test/exn (Circle-radius tv) "")
  ;;raises an error, no such field present
#+end_src

#+RESULTS:
#+begin_src racket
#t
#f
16
#+end_src

*** Pattern matching
- Don't want to accidentally get a field that doesn't exist
- Almost always want to use the fields in the solution
- Solution: pattern-matching
#+begin_src racket :noweb strip-export :exports both
<<shape-defn>>
(define (area [shp : Shape]) : Number
  (type-case Shape shp
     [(Rectangle l w)
       (* l w)]
     [(Circle r)
       (* 3.14 (* r r))])
)
(area tv)
(area loonie)
#+end_src

#+RESULTS:
#+begin_src racket
144
3.14
#+end_src

*** Total Matching
- Missing a case in pattern matching is a /syntax error/
- Lets us know we are safe
- Can add an else clause to handle multiple cases
  + See Racket window
*** E.g. Representing Failure
+ In plait standard library
#+begin_src racket
(define-type (Optionof 'a)
  (none)
  (some [v : 'a]))
#+end_src
+ Pattern matching guarantees no null pointer errors
  - We'll see a more detailed example

*** Most Generic Form
#+begin_src racket
(define-type (Either 'a 'b)
  (Left [inLeft : 'a])
  (Right [inRight : 'b])
)
#+end_src
- You can define all (non-recursive) datatypes  with this and pairs
- e.g. Shape is ~(Either (Number * Number) Number)~

** Recursive Data

*** Self-reference in types
- The real power of datatypes is the ability to have fields of the type being defined
- This allows us to define *trees*
  + of arbitrary depth
- Data can be traversed using recursion


*** Example: Lists as a dataype
#+name: num-list
#+begin_src racket
(define-type NumList
  (Nil)
  (Cons [head : Number] [tail : NumList]))
#+end_src
- Note: this is not quite how lists are defined in Racket/plait
  + But they could be!
- Recursive fields in datatype $\to$ recursive calls in template
#+begin_src racket :noweb strip-export
<<num-list>>
(define (sum [xs : NumList])
  (type-case NumList xs
             [(Nil)
              0]
             [(Cons h t)
              (let ([sumRest (sum t)])
                    (+ h (sum t)))
              ]))
(sum (Cons 100 (Cons 20 (Cons 3 (Nil)))))
#+end_src

#+RESULTS:
#+begin_src racket
123
#+end_src

*** Example: Filesystem
+ Model of a file system
  - Not how is implemented on disk
#+name: fs-defn
#+begin_src racket
(define-type Filesystem
  (File [name : String]
        [data : Number])
  (Folder [name : String]
          [contents : (Listof Filesystem)]))
#+end_src

*** Linear Search using Recursion

- Find the first matching file
#+name: fs-search
#+begin_src racket :noweb strip-export

(define (search [target : String]
                [fs : Filesystem]) : (Optionof Number)
  (type-case Filesystem fs
             [(File name data)
              (if (string=? name target)
                  (some data)
                  (none))]
             [(Folder _ contents)
               (searchList target contents)]))
#+end_src

*** Helper Function: Searching the list
- We have mutually recursive types
  + ~Filesystem~ contains ~(Listof Filesystem)~
  + ~(Listof Filesystem)~ contains ~Filesystem~
- So we use mutually-recursive functions

#+name: fs-searchlist
#+begin_src racket

(define (searchList [target : String]
                    [files : (Listof Filesystem)])
        : (Optionof Number)
  (type-case (Listof Filesystem) files
             [empty (none)]
             [(cons h t)
              (let ([result (search target h)])
                (if (none? result)
                    (searchList target t)
                    result))
              ]))
#+end_src
*** Testing the search
#+begin_src racket :noweb strip-export :exports both
<<fs-defn>>
<<fs-search>>
<<fs-searchlist>>
(define InnerSolarSystem
  (Folder "Sun"
          (list (File "Mercury" 1)
                (File "Venus" 2)
                (Folder "EarthSystem"
                        (list (File "Earth" 3)
                              (File "Moon" 3.5)))
                (Folder "MarsSystem"
                        (list (File "Mars" 4)
                              (File "Phobos" 4.3)
                              (File "Diemos" 4.6))))))

(search "Moon" InnerSolarSystem)
(search "Jupiter" InnerSolarSystem)
#+end_src

#+RESULTS:
#+begin_src racket
(some 3.5)
(none)
#+end_src



* Abstract Syntax and Parsing
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides004-syntax.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** The Big Picture


*** Life of a program

- The Language Pipeline:

#+latex: {\tiny
#+ATTR_LATEX: :align p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}
| Source code | $\xrightarrow{\text{parsing}}$ | Abstract syntax tree | $\xrightarrow{translation}$ | Core Syntax                | $\xrightarrow{evaluation}$  | Result              |
|             |                                |                      |                             |                            |                             |                     |
| \nohyphens{text file} | \nohyphens{lexing / tokenizing first} | \nohyphens{data structure } | \nohyphens{desugaring / compilation} | simpler AST / machine code | interpreter, execute on CPU | value, side effects |
|             |                                |                      |                             |                            |                             |                     |
#+latex: }



*** Syntax vs Semantics
- Can have many syntaxes that parse to the same abstract syntax
  + Different keywords
  + Different operator names
  + Different order of expressions
- E.g. plait vs shplait


** Describing Syntax

*** EBNF
- Extended Backus-Naur form
  + Named after scientists who worked on Algol

- Notation for Context Free Grammars
  + See CS 411

- Describes which strings are valid expressions/statements/etc. in a language

- Generative

  + Gives a process for generating valid strings in the language

  + String is valid if and only if it's generated by the grammar

*** Example
#+begin_src
<expr> ::=
    "{" "+" <expr> <expr> "}"
  | "{" "*" <expr> <expr> "}"
  | number
#+end_src
- ~<expr>~ is a /nonterminal/
  + A symbolic variable that doesn't show up in the final string, but is replaced using a rule
- ~::=~ means /can be one of/
- ~|~ separates the possibilities
- Literal strings are in quotation marks
  + Usually for keywords, operators or parentheses
- ~number~ is a literal number e.g. some sequence of digits

*** Generating a string
- Start with a single non-terminal
  + e.g. ~<expr>~ for an expression
- Until you have a string with no non-terminals, repeatedly:
  + Replace a non-terminal with one of its variants
    - i.e. one of the things on the right of ~::=~
- Examples:
  + ~<expr> -> 3~
  + ~<expr> -> {+ <expr> <expr>} -> {+ 2 <expr>} -> {+ 2 5}~
  + ~<expr>~
    - ~-> {* <expr> <expr>}~
    - ~-> {* {+ <expr> <expr>} <expr>}~
    - ~-> {* {+ 5 <expr>} <expr>}~
    - ~->{ * {+ 5 100000} <expr>}~
    - ~-> { * {+ 5 100000} -3}~

** Parsing and Abstract Syntax

*** Parse Trees
- Notice that the different replacements didn't affect each other
  + Can effectively replace them in parallel
- Tree structure
  + Non-terminal is a node
  + Terminal is a leaf
  + Edge is application of rule from grammar
- Can make a datatype representing these trees
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr]))
#+end_src

#+RESULTS:
#+begin_src racket
#+end_src

*** Abstract Syntax
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr]))
#+end_src
- This is called the /abstract syntax/ for the programming language
- A value of this type is called an /abstract syntax tree/
  + AST for short

*** Parsing
- The process of turning source code (linear string) into abstract syntax (tree)
  + Turns the program into a thing we process recursively
  + Tree structure mirrors structure of the program
- Can fail
  + What if the string isn't generated by the grammar?

*** Parsing in this class
- Parsing is an interesting problem
- But it's not an interesting /programming languages/ problem
- We will use Racket/plait features to do most of the parsing for us
  + Use  quoting to write s-expressions directly
    - Does the hard work of figuring out nested brackets

*** S-expressions
- Symbolic expressions
  + Goes back to John McCarthy, LISP, early days of AI at MIT
  + s-exp for short
- An S-expression is either
  + A symbol
  + A literal (number, boolean, string, etc.)
  + A bracketed list of S-expressions
- The backtick ~`~ in Racket says "interpret the next thing as an s-exp"
  + Single-quote ~'~ does the same but doesn't handle literals, just symbols
  #+begin_src racket
    `a
    `(+ 2 3)
    `(a b c d (+ 2 3) #t (#f #f))
  #+end_src

  #+RESULTS:
  #+begin_src racket
  `a
  `(+ 2 3)
  ~(a b c d (+ 2 3) #t (#f #f))
  #+end_src
- We'll use backtick as the first half of our parser
  + Easier to deal with s-expressions than strings
*** From S-exp to AST
- S-expression is a tree
  + Might not be a tree representing anything in our language
- If s-exp is literal
  + Generate the literal in our AST
  + Error if it's unsupported
- If it's a list
  + Check the first thing in the list
  + If it's an operation, check that we have the right number of arguments
  + If we do, (try to) parse each argument
- Otherwise, fail
- Uses the ~s-exp-match?~ function
  + Don't need to memorize how it works, we'll give you the parsers for the most part
*** Example Parser
#+name: arith-parse
#+begin_src racket
(define (parse [s : S-Exp]) : Expr
  (cond
    [(s-exp-match? `NUMBER s) (NumLit (s-exp->number s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (Plus (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (Times (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [else (error 'parse "invalid input")]))
#+end_src
* Arithmetic: Our First Interpreter
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides005-arith.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** Interpreters: Overview

*** The Church Turing Thesis

#+ATTR_LATEX: :align p{0.2\textwidth}p{0.2\textwidth}p{0.2\textwidth}p{0.2\textwidth}
|   | [[./img/Alonzo_church.jpg]]     | [[./img/goedel.jpg]]                        | [[./img/turing.jpg]]            |
|   | Alonzo Church                   | Kurt GÃ¶del                                  | Alan Turing                     |
|   |                                 |                                             |                                 |
|   | /\nohyphens{(lambda calculus)}/ | /\nohyphens{(general recursive functions)}/ | /\nohyphens{(Turing machines)}/ |
|   |                                 |                                             |                                 |





*** The Church Turing Thesis
**** Turing Completeness
- The following can all simulate each other:
  + Turing Machines
  + General-recursive functions
  + Lambda calculus (we'll see later)
- We call a programming language that can simulate a Turing machine
  /Turing Complete/
  + Any language with ~while~ loops or recursion is Turing Complete
**** All Turing Complete Languages can simulate each other


*** Turing Completeness and Interpreters
- You can write an interpreter for any language in any Turing-complete language
- The features of a language you're interpreting are /completely unrelated/ to the features of the language the interpreter is written in
  +  Sometimes you can piggyback on the implementation language features, but that's a matter what's /convenient/, not what's /possible/

*** Keeping it all straight
- The implementation language is NOT the language you're interpreting
- In this class, the implementation language is Racket/plait
- We'll write interpreters for a bunch of small languages
  + We'll call them "Curly" because we write them with curly brackets
  + Write Curly programs in Racket files using quotation

*** General Form of an Interpreter
#+begin_src racket
(define (interp [e : Expr]
                [x : SomeContext]
                ...
                [y : OtherContext])
        : Value
  ....)
#+end_src
- ~Expr~ is the is the AST datatype for whatever language we're interpreting
- What the context arguments and ~Value~ datatype are depend on the language
  + Initially we have no context arguments, and ~Value~ is very simple
  + Will get more complicated as we go through the course

*** Our First Interpreter
#+name: arith-ast
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr]))
#+end_src
- Recursive function on structure of syntax
  + Base cases are literals, translate directly into values
  + Recursive cases are operations
    - Interpret sub-expressions recursively
    - Combine according to value version of the operation


*** Our First Interpreter
- Interpreting arithmetic, so values are just plait ~Number~

#+name: arith-interp
#+begin_src racket :noweb strip-export :exports both
<<arith-ast>>
<<arith-parse>>
(define (interp [e : Expr] ) : Number
  (type-case Expr e
             [(NumLit n) n]
             [(Plus l r)
                (+ (interp l) (interp r))]
             [(Times l r)
                (* (interp l) (interp r))]))
(define (eval s-exp) (interp (parse s-exp)))
(eval `3)
(eval `{+ 2 5})
(eval `{+ {* 1 {+ 2 1}} {+ {* 3 4} {* 0 1000000}}})
#+end_src

#+RESULTS: arith-interp
#+begin_src racket
3
7
15
#+end_src

*** Adding features
- Need to update
  + AST definition
  + Parser
  + Interpreter
- Example: ~{if0 cond x y}~
  + Evaluates to ~x~ if ~cond~ evaluates to ~0~
  + Evaluates to ~y~ if ~cond~ evaluates to anything else

*** Updating the dataype
#+name: arith-ast
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr]))
  ;;NEW
  (If0 [test : Expr]
       [thenBranch : Expr]
       [elseBranch : Expr])
#+end_src

*** Updating the parser
#+begin_src racket
    [(s-exp-match? `{if0 ANY ANY ANY} s)
     (If0 (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))
            (parse (fourth (s-exp->list s))]
#+end_src

*** Updating the interpreter
#+begin_src racket :noweb strip-export :exports both
(define (interp [e : Expr] ) : Number
  (type-case Expr e
             [(NumLit n) n]
             [(Plus l r)
                (+ (interp l) (interp r))]
             [(Times l r)
                (* (interp l) (interp r))])
  
             [(If0 test thenBranch elseBranch)
               (if (= 0 (interp test))
                 (interp thenBranch)
                 (interp elseBranch)
               )])
#+end_src
* Desugaring: Our First Elaborator
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides006-desugar.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Syntactic Sugar
*** What is syntactic sugar
- Some language features strictly increase the power of a language
  + Let you do things that can't be done any other way
- Some language features aren't strictly necessary, but are nice to have
  + Otherwise we'd just code in machine code/assembly all the time
- These "nice to haves" are called /syntactic sugar/
  + They "sweeten" the experience of programming
*** Desugaring
- When one feature can be expressed in terms of another, sometimes we implement it by /desugaring/
  + Translating the AST for a feature into other language features
- Desugared features: no case in the interpreter
  + Instead, translate to a smaller "core" AST type
  + Keeps the interpreter small, easier to maintain
- Have two types for AST
  + Surface AST
  + Core AST
*** Example: Subtraction
- We'll add subtraction to our language
  + /without changing the interpreter at all/
- Separate AST into surface and core AST
- Add translation from surface to core AST
*** Subtraction: Datatype
- First need the surface AST
#+begin_src racket
(define-type SurfaceExpr
  (SurfNumLit [n : Number])
  (SurfPlus [left : SurfaceExpr]
        [right : SurfaceExpr])
  (SurfTimes [left : SurfaceExpr]
         [right : SurfaceExpr])
  (SurfIf0 [test : SurfaceExpr]
       [thenBranch : SurfaceExpr]
       [elseBranch : SurfaceExpr])
  (SurfSub [left : SurfaceExpr]
       [right : SurfaceExpr]))
#+end_src
*** Subtraction: Parser Case
#+begin_src racket
(define (parse [s : S-Exp]) : SurfaceExpr
  ...
    [(s-exp-match? `{- ANY ANY} s)
     (SurfSub (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))])
#+end_src
*** Subtraction: Elaborator
- Define function that translates from ~SurfaceExpr~ to ~Expr~
#+begin_src racket
(define (elab [surf : SurfaceExpr]) : Expr
  (type-case SurfaceExpr surf
             [(SurfNumLit n) (NumLit n)]
             [(SurfPlus x y) (Plus x y)]
             [(SurfTimes x y) (Times x y)]
             [(SurfIf0 test thn els) (If0 test thn els)]
             ;; Sub isn't in our core syntax
             [(SurfSub x y) (Plus x (Times (NumLit -1) y))])
  )
#+end_src
*** Compilation vs. Elaboration vs. Desugaring
- Technically we just wrote our first compiler
  + Translated a small language into an even smaller one
- Compilation is just a bunch of desugaring passes
  + Simpler and simpler languages untill we have something simple enough for assembly code





* Functions, Variables and Substitution
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides007-subst.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Overview: Functions
*** Adding functions to the language
- Want to be able to re-use code, compute in terms of variables
- Two new Curly features
- Function definitions
  + ~{define {f x} {+ x 3}}~
- Function calls
  + Sometimes called /function applications/
  + ~{f 10}~, produces ~13~
  + To start: single argument, inputs and outputs number
*** Syntax: Definitions
- New datatype for function definitions
#+begin_src racket
(define-type FunDef
  (mkFunDef [name : Symbol]
            [arg : Symbol]
            [body : Expr]))
#+end_src
*** Parser: Definitions
- New parser
  + Note: function definition is not an expression
  + Need to elaborate body after parsing
#+begin_src racket
(define (parse-fundef [s : S-Exp]) : FunDef
  (cond
    [(s-exp-match? `{define {SYMBOL SYMBOL} ANY} s)
     (mkFunDef
        (s-exp->symbol
           (first (s-exp->list (second (s-exp->list s)))))
         (s-exp->symbol
            (second (s-exp->list (second (s-exp->list s)))))
         (elab (parse (third (s-exp->list s)))))]
    [else (error 'parse-fundef "invalid input")]))
#+end_src
*** New Expression Syntax
- We need a way to:
  + Call a function
  + Refer to the parameter of a function inside its body
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr])
  (If0 [test : Expr]
       [thenBranch : Expr]
       [elseBranch : Expr])
  (Var [x : Symbol])
  (FunCall [f : Symbol]
           [arg : Expr]))
#+end_src
- Also add variables and calls to surface syntax
*** Interpreting Variables
- What is the meaning of a variable in a program?
  + Variable is just a placeholder for whatever the value is given to the function
- Interpreting a variable is an *error*
  + Similar to "out of scope" or "undefined variable" errors
- Could statically check if variable was out of scope
  + Might do later in the course
*** Interpreting Function Calls
- Function call:
  + Looks up body of function
  + Replaces variable with value given
  + Evaluates the body after that replacement
- Interpreter needs context now
  + List of function definitions
    #+begin_src racket
     (define (interp [expr : Expr]
                     [defs : (Listof FunDef)]) : Number
       ....)
    #+end_src
*** Looking up function definitions
- Iterate through a list of definitions until we find one that matches
  #+begin_src racket
(define (get-fundef [s : Symbol] [defs : (Listof FunDef)]) : FunDef
  (type-case (Listof FunDef) defs
    ;; If we hit empty list, then we didn't find the function
    [empty (error 'get-fundef (string-append "No function with name " (to-string s)))]
    ;; Check if the first one in the list is what we're looking for
    ;; If it is, return it.
    ;; Otherwise, look in the rest of the list.
    [(cons def otherDefs)
     (if (equal? (mkFunDef-name def) s)
         def
         (get-fundef s otherDefs))]))
  #+end_src

*** Substitution
**** How can we replace a variable in an expression?
- More recursion!
- "Replace all occurrences of the variable ~x~ with the expression ~s~ inside of the expression ~t~"
- Do this by traversing the expression recursively
- Critical operation in programming languages
*** Cases for Substitution
  + Variable ~y~: check if ~y~ = ~x~ i.e. it's the variable the one we're replacing
    - If it is, produce ~s~
    - Otherwise, produce ~y~ again
  + Everything else: recursively substitute in the sub-expressions
    - Will have more complex cases later
*** Code for Substitution
#+name: subst-start
#+begin_src racket
;; `(subst x s t)` replaces all occurences of `x` in `t` with `s`.
;; We use this to implement function calls
(define (subst [toReplace : Symbol]
               [replacedBy : Expr]
               [replaceIn : Expr]) : Expr
  (type-case Expr replaceIn
    ;; Base case: we're replacing a variable in an expression
    ;; where that expression is a variable
    [(Var x)
     ;; Check if it's the variable we're replacing
     (if (equal? x toReplace)
         replacedBy ;; If so, produce what we're replacing it with
         (Var x))] ;; else produce the original variable
    ;; Number is a leaf, no sub-expressions
    ;; so return it unchanged
    [(NumLit n) (NumLit n)]
    ;; ...
#+end_src
*** Code for Substitution (ctd)
#+begin_src racket :noweb strip-export
    <<subst-start>>
    ;; Plus has two sub-expressions,
    ;; so we replace the variable in both sub-expressions
    [(Plus l r)
     (Plus (subst toReplace replacedBy l)
           (subst toReplace replacedBy r))]
    ;; other operations work similarly
    [(Times l r)
     (Times (subst toReplace replacedBy l)
           (subst toReplace replacedBy r))]
    [(If0 test thn els)
     (If0 (subst toReplace replacedBy test)
           (subst toReplace replacedBy thn)
           (subst toReplace replacedBy els))]
    ;; Have to decide how to handle namespaces
    ;; For now, functions and variables are different namespaces
    ;; so we don't ever replace a function name in subst
    [(Call funName arg)
     (Call funName (subst toReplace replacedBy arg))]))
#+end_src
*** Bringing it together
- Interpret a function call by:
  + Looking up definition
  + Evaluating argument
  + Replacing function parameter with value of argument
    - using substitution
#+begin_src racket
[(Call funName argExpr)
     (let* ([argVal (interp defs argExpr)]
            [def (get-fundef funName defs)]
            [argVar (mkFunDef-arg def)]
            [funBody (mkFunDef-body def)])
       (interp defs (subst argVar (NumLit argVal) funBody)))]
#+end_src
* Review
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides008-review.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** Overview

*** The Story So Far
- Functional Programming
  + Immutable variables
  + Recursion
  + Data-types
  + Type-case
- Interpreters
  + BNF
  + Abstract Syntax
  + Parsing
  + Interpretation
  + Desugaring
  + Substitution

** Functional Programming
*** How to evaluate functional programs
- Repeat until we have a value:
  + Take all the functions defined with ~define~
  + Replace them with their definitions, with arguments replacing parameters
  + Simplify any ~if~, ~cond~, ~type-case~ etc.

** The Languages We've Built

*** Curly
- Many different languages
  + Gradually adding features
  + I'll give them names so we can tell them apart
- Each time we add a new feature, is a new language
- Called "curly because" we write with Curly-brackets
- Write as S-expression strings
  + Racket backtick ~`~ turns strings into S-expressions
  + Separates different names/symbols and nests brackets
  + Parse turns S-expressions into AST
*** Curly-Arith
  + Just has addition, multiplication, and numbers
  + AST type ~Expr~
  + Value type ~Number~
  + Pipeline:
    - String $\to_\text{backtick}$ S-Exp $\to_\text{parse}$ Expr $\to_\text{interp}$ Number
*** Curly-Cond
- Adds ~if0~
  + Conditional expressions, branching depending on whether a value is 0
  + Adds a constructor to ~Expr~
  + Adds case to parser and interp
*** Curly-Sub
- Adds ~{- x y}~
- ~interp~ unchanged from Curly-Cond
- Introduces an intermediate AST type ~SurfExpr~
  + Expressions with syntactic sugar
- /Desugaring/ converts ~SurfExpr~ to ~Expr~
  + Translate away certain features
  + Also called /elaboration/
- ~{- x y}~ is the same as ~{+ x {* -1 y}}~
- String $\to_\text{backtick}$ S-Exp $\to_\text{parse}$ SurfaceExpr $\\ \qquad\qquad \to_{elab}$ Expr $\to_\text{interp}$ Number
*** Curly-Fun
- Adds function definitions and function calls
  + Single parameter functions, number in, number out
- Functions have /parameters/
  + So we add variables to ~Expr~ and ~SurfExpr~
- Interpreter now parameterized by list of function definitions
  + Parsed separately
- Function calls interpreted by /substitution/
  + Replace variable with value of concrete argument


* Environments, Binding, and Scope
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides009-environments.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Overview
*** The Road So Far
- Functional Programming (Plait Tutorial)
- Parsing (PLAI ch2)
- Interpreters (PLAI ch3)
- Desugaring (PLAI ch4)
- Functions (PLAI ch5)
*** The Road to Midterm

- Today: Environments in Curly (PLAI ch6)
- Tues: Lambda and First-class Functions in Plait
- Wed: Replacements for Recursion in Plait
- Thurs: Implementing Lambda in Curly (PLAI ch7)
- Mon: Closures and Environments in Curly (PLAI ch7)
- Tues/Wed: lectures (not included on midterm)
- Thurs: *MIDTERM*
**** Everything up to and including Closures may appear on the midterm

** Environments

*** Functions Review
  + Evaluate their argument
  + Lookup the function defn (variable, body)
  + Replace the parameter variable with the argument value in the body
  + Evaluate the result
  + If we ever interpret a variable, raise an error
*** The Problem
- Each substitution is $\mathcal{O}(n)$ where $n$ is the number of nodes in the function body AST
- This is /in addition/ to the cost of actually evaluating the function
  + Very slow!
- Want a way to have $\mathcal{O}(1)$ function calls
  + Not including the time to evaluate the function body
- Substitution is forgetful
  - Just replaces function variable with expression
  - Not very useful for debugging
*** The Solution: Environments
- Data structure for /deferred substitution/
  + List of variable/value pairs
- Intuition:
  - Instead of replacing all ~x~ with value ~v~, keep a list of replacements you need to do
  - When you interpret ~x~, check the environment before raising an error
  - If there's an entry for ~x~ in the environment, return that
    + Error otherwise
    + Means reference to undefined variable
*** The Environment Data Structure: Bindings

   #+name: binding-deftype
#+begin_src racket
;; Just a pair, but we get better names than fst and snd
(define-type Binding
  (bind [name : Symbol]
        [val : Number]))
#+end_src
#+begin_src racket :exports both :noweb strip-export
<<binding-deftype>>
;; Get helper functions from the type-def
(bind-name (bind 'x 3))
(bind-val (bind 'x 3))
#+end_src

*** The Environment Data Structure: Environments

#+begin_src racket :noweb strip-export :exports both
<<binding-deftype>>
;; Lets us write Env instead of (Listof Binding)
;; But it's not defining a new type,
;; just a new name for the same type.
(define-type-alias Env (Listof Binding))
;; Environment is either empty or extended env
(define emptyEnv : Env
  empty)
(define (extendEnv [bnd : Binding]
                   [env : Env])
        : Env
  (cons bnd env))

emptyEnv
(extendEnv (bind 'x 3) (extendEnv (bind 'y 4) empty))
#+end_src

*** Looking up variables
- Find the *first* binding in the environment
  + This is important for shadowing
- Just a linear search, like we've seen lots already
#+begin_src  racket
(define (lookup [n : Symbol] [env : Env]) : Number
  (type-case (Listof Binding) env
   ;; Can't find a variable in an empty env
   [empty (error 'lookup "undefined variable")]
   ;; Cons: check if the first binding is the var
   ;; we're looking for.
   ;; Return its value  if it is, otherwise
   ;; keep looking in the rest of the list
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-val b)]
                       [else (lookup n rst-env)])]))
#+end_src
*** Intepreting CurlyFundef with Environments
- We can change the implementation /without changing the surface language/
- Programs should run the exact same in both interpreters
- Strategy: add an extra context argument for Environment
  + Unlike fundefs, this will /change across recursive calls/
#+begin_src racket
(define (interp [env : Env]
                [defs : (Listof FunDef)]
                [e : Expr] ) : Number
  (type-case Expr e
             ....))
#+end_src
*** Case: Plus etc.
- Exactly like before, except we have to pass the environment in the recursive call
- Other operations are similar
#+begin_src racket
;; {+ e1 e2} evaluates e1 and e2, then adds the results together
    [(Plus l r)
     (+ (interp env defs l) (interp env defs r))]
#+end_src
*** Case: Variable
- Can't return an error, because we might have added a deferred substitution to the environment
- So we look in the environment and see if there's a value /bound/ to x
- If there is return it
  +  Otherwise, variable not found error
#+begin_src racket
[(Var x)
      (lookup x env)]
#+end_src
*** Case: Function call
- Just like before, we get the function body + variable, and value for argument
- Still interpret body
- Instead of replacing in body, put a variable-value pair in the environment
  + Called /binding/ the variable to its value
#+begin_src racket
[(Call funName argExpr)
     (let* ([argVal (interp env defs argExpr)]
            [def (get-fundef funName defs)]
            [argVar (mkFunDef-arg def)]
            [funBody (mkFunDef-body def)])
       (interp (extendEnv (bind argVar argVal) emptyEnv) ;;<------
               defs
               funBody))]
#+end_src
*** Static Scoping
- We evaluated the body of the function in the empty environment, plus a value for its variable
  + Didn't extend the additional environment
- Want functions to be /abstractions/
  + Should be able to predict how a function behaves from how it's called
  + Don't want result to depend on context, just arguments
- Gives the same results as substitution.
- We call this /static scoping/
- If we extend the environment from the call site, we get /dynamic scoping/
*** Static Scoping Definition
- A language has /static scoping/ if undefined variables in a term get their values from the environment where the function is /defined/
  + Right now, variables come from top-level functions, so undefined variables
    are always an error
  + We'll see more of this later
- A language has /dynamic scoping/ if undefined variables get their values from the point where the function is /called/
*** Static Scoping Exapmple
#+begin_src
{define {f x} {+ x y}}
{define {g y} {f y}}
{g 3}
#+end_src
- Static scoping says this is an error
  + No value for ~y~ in body of ~f~
- Dynamic scoping produces 6
  + Looks up ~y~ from ~g~ when evaluating ~f~
- Dynamic scoping is WRONG
  + You should understand it, but know that static scoping is what we want

** Implementing Let
*** Curly-Let
- New language: Curly-Let
- Curly-Fundef, but with one new feature
  + ~{letvar x e1 e2}~
    - Gives ~x~ the value ~e1~ in the expression ~e2~
    - Called letvar so we don't confuse with plait
- We'll implement with both substitution and environments

*** Abstract Syntax
#+begin_src racket
(type-def Expr
  ....
  [(Letvar [x : Symbol]
           [xval : Expr]
           [body : Expr])]
          )

#+end_src
- Parsing and Desugaring are the same as usual
  + See ~Curly-Let.rkt~

*** Interpreting: Substitution
- Want variable to have the given value in the body
  + So just substitute the value for the variable in the body
- Key detail: expression only evaluated once
  + Can have exponential speedup in some algorithms
#+begin_src racket
(define (interp [defs : (Listof FunDef)] ;;NEW
                [e : Expr] ) : Number
  (type-case Expr e
        ;; ....
     [(LetVar x xexp body)
        (interp defs (subst x (NumLit (interp defs xexp)) body))])
#+end_src


*** Substituting in a Let Expression
- ~{letvar x e1 e2}~ /binds/ ~x~ in e2
- So when substituting in ~e2~ we don't ever replace x
- Implements shadowing
#+begin_src racket
(define (subst [toReplace : Symbol]
               [replacedBy : Expr]
               [replaceIn : Expr]) : Expr
  (type-case Expr replaceIn
    [(LetVar x xexp body)
       (LetVar x
               (subst toReplace replacedBy xexp)
               (if (symbol=? x toReplace)
                   body
                   (subst toReplace replacedBy body)))]))
#+end_src

*** Interpreting: Environments
- Interpret the variable's value in the current environment
- Interpret the let body in the /extended/ environment
- When we hit ~x~ we'll look in the env
#+begin_src racket
(define (interp [env : Env]
                [defs : (Listof FunDef)]
                [e : Expr] ) : Number
  (type-case Expr e
        ;; ....
     [(Letvar x xexp body)
      (let ([xval (interp env defs xexp)])
        (interp (extendEnv (bind x xval) env)
                defs body))])
#+end_src

*** Scope
- Notice that we only add to the env to interp ~body~, not ~xexp~
- This is because ~x~ is /in scope/ for ~body~ but not ~xexp~
- We say the *scope of a variable* is the part of the program in which its value is either substituted or bound
- Let /extends/ scope by adding a variable, while calls /transfer/
  scope to the function
- Later we'll see more complex examples of scope
  + e.g. in Plait, ~let~ and ~let*~ have different rules for what's in scope

*** The Stack

- Environments have a /stack/ structure
  + Push on new bindings when variables are defined
  + Don't directly pop, but will sometimes interpret in the unextended environment
- If we bind a value to a variable that's already in the environment, we say we /shadow/ the old binding
  + ~lookup~ always takes the most recent binding
- Part of the /call stack/
  + Theoretical in Curly
  + Actually implemented for most languages
  + Every time we call a function or define a variable we push onto the call stack
- Curly-Let and others have an /implicit/ call stack
  + We don't keep the data structure ourselves
  + Instead, call ~interp~ recursively to add to the /Plait/ call stack
  + When finished eval, plait returns is to part waiting for the result

*** Shadowing Example
- ~{letvar x 3 {letvar x 4 {+ 3 x}}}~
  + Looks at most recent definition
  + So should be 7
- Substitution: ~subst~ doesn't replace ~x~ in ~{+ 3 x}~ because it is bound
- Environments: ~(x,4)~ is at the top of the environment, so ~interp~ of ~x~ finds ~4~

*** Design Choices
- There are /high level design choices/ for programming languages
  + How to deal with variable name collisions (shadowing)
  + How to deal with undefined variables (static vs. dynamic scope)
- Decisions *are made concrete* in the implementation
  + Behavior of ~subst~ on bound variables
  + What environment ~interp~ is passed for function bodies

* Functional Programming 2: First-Class Functions
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides010-lambda.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Higher Order Functions
*** Functions on Functions
- Functions let us be abstract over the data they work on
- But why can't we be abstract over what they do to that data?
  + We can!
- A *higher order function* is a function that takes functions as an argument,
  or returns functions as a value.
- Examples:
  + Callbacks
    - Give a GUI element the function to run when clicked
  + Threads
    - Give the function for each thread to compute
*** Function types
- Type ~(T1 T2 ... Tn -> S)~
  + The type of functions that:
    - take $n$ arguments
    - each with type $T_i$ respectively
    - produces a result of type $S$
- Functions can be defined, where their arguments /are function types!/
*** First Class Functions
- We say a language has /first class functions/ if functions are treated like any
  other expression/value in a language
  + We can construct them at any point, not just at the top level
  + We can give them as arguments to functions
  + We can return them as results of functions
*** Example: Repeatedly apply a function
#+name: applyNTimes
#+begin_src racket
(define (applyNTimes [f : (Number -> Number)]
                     [x : Number]
                     [nTimes : Number]) : Number
  (if (<= nTimes 0)
      x
      (applyNTimes f (f x) (- nTimes 1))))
#+end_src


- Takes 3 arguments
  + A function from Number to Number
  + A number
  + A number
- Returns a number
- In the body:
  + Calls the parameter ~f~ as a function on ~x~

*** ctd
#+begin_src racket :noweb strip-export :exports both
<<applyNTimes>>
(define (timesTen x) (* 10 x))

(applyNTimes add1 3 5)
(applyNTimes timesTen 3 5)
#+end_src
- Takes whatever function we pass in, applies it to 3, 5 times
  + ~(f (f (f (f (f 3)))))~
*** Example: apply an operation to each number in a list
#+name: mapNum
#+begin_src racket
(define (mapNum [f : (Number -> Number)]
                [xs : (Listof Number)]) : (Listof Number)
  (type-case (Listof Number) xs
             [empty empty]
             [(cons x rest)
                (cons (f x) (mapNum f rest))]))
#+end_src
- Takes a function from Numbers to Numbers, and a list of numbers
- Applies ~f~ to each element of the list
  + Apply ~f~ to everything in the empty list
    - Produces empty list
  + Apply ~f~ to each in  ~(cons x rest)~
    - Apply ~f~ to ~x~, recursively apply ~f~ to everything in ~rest~
    - Combine the results with ~cons~

*** ctd
#+begin_src racket :exports both :noweb strip-export
<<mapNum>>
(define (timesTen x) (* 10 x))
(mapNum add1 '(1 2 3 4))
(mapNum timesTen '(1 2 3 4))
#+end_src
*** Creating Anonymous Functions
- So far, have only given functions that we defined with ~define~ as arguments to other functions
- What if we want to make a small little function that we use only once?
- What if we want to make a function dynamically?
*** Lambda
#+begin_src
(lambda (x) body)
#+end_src
- Creates a function with argument ~x~ that returns ~body~
- ~x~ may occur in body
- Is an expression, not a declaration
  + Can occur anywhere else
*** Lambda variations
#+begin_src racket
;; Type annotation
(lambda ([x : Number]) : Number
  (+ x 1))

;; Multiple arguments
(lambda (x y) (+ x (+ x y)))

;;Multiple type annotations
(lambda ([x : Number]
   [y : Number]) (+ x (+ x y)))

;; Unicode Greek lambda
;; In Dr. Racket: either cmd-\ or ctrl-\ depending on os
(Î» (x) (+ x x))
#+end_src
*** Example
#+begin_src racket :exports both :noweb strip-export
<<mapNum>>
(define (timesTen x) (* 10 x))
(mapNum timesTen '(1 2 3 4))
(mapNum (lambda (x) (* x 10)) '(1 2 3 4))
#+end_src


*** Define as sugar
- ~(define (f x) body)~
- Same as ~(define f (lambda (x) body))~
- Defining functions is /syntactic sugar/ for lambda in Plait

*** Lambda in a context
- Don't have to use lambda at the top level
- Can refer to other variables in the body of the lambda
#+begin_src racket :noweb strip-export :exports both
<<mapNum>>
(define (addNToEach [numToAdd : Number]
                    [xs : (Listof Number)]) : (Listof Number)
  (mapNum (lambda(x) (+ x numToAdd)) xs))
(addNToEach 3 '(1 2 3 4))
#+end_src

#+RESULTS:
#+begin_src racket
'(4 5 6 7)
#+end_src
- The lambda *captures* the variable ~numToAdd~
- Dynamically creates the function that adds its argument to whatever ~numToAdd~ is

*** Functions as return values
- We can also make functions that produce other functions as a result
  + Just use ~lambda~ in the body of the function
#+begin_src racket :noweb strip-export :exports both
<<mapNum>>
(define (makeAdderWith n) : (Number -> Number)
  (lambda (x) (+ n x)))
(makeAdderWith 3)
(mapNum (makeAdderWith 3))
#+end_src

*** Combinators
- Functions that take and return functions
- Can "lift" operations to whole functions
- Create a new function by specifying how it should behave on each input
  + Lambda lets us refer to this variable
#+begin_src racket :noweb strip-export :exports both
<<mapNum>>
(define (+fun [f : (Number -> Number)]
              [g : (Number -> Number)]) : (Number -> Number)
  (lambda (x) (+ (f x) (g x))))
;; e.g. Make the function that computes
#+end_src

*** Example: Beyond Numbers
#+begin_src racket :exports both
(define (liftOption [f : (Number -> Number)])
  : ((Optionof Number) -> (Optionof Number))
  (lambda ([optionN : (Optionof Number)])
    (type-case (Optionof Number) optionN
      [(none) (none)]
      [(some x) (some (f x))]
      )))
(define optionPlusOne (liftOption add1))
(optionPlusOne (some 3))
(optionPlusOne (none))
#+end_src

#+RESULTS:
#+begin_src racket
(some 4)
(none)
#+end_src

* Polymorphic Higher-Order Functions
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides011-map.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Highly Generic Programming
*** Polymorphic Functions
- Higher-order functions are even more powerful when combined with type variables
- Allows us to say "This works on any type, as long as that type supports this kind of operation"
- Express ideas like "do this to every element in a list"
*** Example: Sorting
#+begin_src racket
(define (sortNumbers [xs : (Listof Number)]) : (Listof Number)
  ....)

;; These implementations are probably doing 99% the same thing
;; except they're using different comparison operators
(define (sortById [xs : (Listof (Number * String))])
        : (Listof (Number * String))
  ....)

;; What we really want is this:
(define (sortBy [xs : (Listof 'a)]
                [compare : ('a 'a -> Boolean)])
  : (Listof 'a)
  ....)
#+end_src
- Sort function that works on any type ~'a~
  + So long as we have a comparison function ~compare~ that can find if one ~'a~ value is <= another
*** Map
- One of the most essential functions on list
- For each element in the list, apply this function to each element
  + Returns the resulting list, original list is unchanged
- If your function takes in type ~'a~ and produces type ~'b~, then ~map~ can turn a ~(Listof 'a)~ into ~(Listof 'b)~
#+begin_src racket
(define (map [f : ('a -> 'b)]
           [xs : (Listof 'a)]) : (Listof 'b)
  (type-case (Listof 'a) xs
             [empty
               empty]
             [(cons x rest)
               (cons (f x)
                     (map f rest))]))
#+end_src
*** Examples
#+begin_src racket :exports both
(map (lambda (x) (* x 1001)) '(1 2 3 4))
(map not '(#t #f #f #t))
(map some '("Hello" "Goodbye"))

#+end_src

#+RESULTS:
#+begin_src racket
'(1001 2002 3003 4004)
'(#f #t #t #f)
(list (some "Hello") (some "Goodbye"))
#+end_src

*** Map does recursion so you don't have to
- Lots of times, we were writing code that looked exactly the same
- Higher-order functions and polymorphism let you turn those patterns into an actual *function*


*** Filter
- Another common function on lists
- Takes a *predicate* for some type:
  + Look at two values and return either true or false
  + Defines a property on that type
- Returns a new list containing only the elements satisfying the predicate
#+begin_src racket
(define (filter [p : ('a  -> Boolean)]
                [xs : (Listof 'a)]) : (Listof 'a)
  (type-case (Listof 'a) xs
             [empty
               empty]
             [(cons x rest)
              ;; Check if the first element satisfies p
              ;; If it does, include it in the results,
              ;; otherwise omit
               (if (p x)
                   (cons x (filter p rest))
                   (filter p rest))]))
#+end_src

*** Filter examples
#+begin_src racket :exports both
(filter (lambda (x) (zero? (modulo x 2)))
        '(1 2 3 4 5 6))
(filter some?
        (list (none) (some "Hello") (none) (some "Goodbye")
              (none) (none) (some "Cheers") (none)))
(filter (lambda (x) (> x 1000000))
        (list 1 2 3 4 (* 100000 100000)) )
(filter (lambda (x) #f) '(1 2 3 4))
#+end_src


*** Using Filter: The Functional Quicksort
#+name: quicksort
#+begin_src racket
(define (sortBy [compare : ('a 'a -> Boolean)]
                [xs : (Listof 'a)]) : (Listof 'a)
  (type-case (Listof 'a) xs
             [empty
               empty]
             [(cons first rest)
               (let*
                 ([smallers
                    (filter (lambda (x) (compare x first))
                            rest)]
                  [biggers
                    (filter (lambda (x) (not (compare x first)))
                            rest)])
                 (append (sortBy compare smallers)
                         (cons first
                               (sortBy compare biggers))))]))

#+end_src

*** How Quicksort works
- An empty list is already sorted
- If a list has at least one element, we can partition that list into everything smaller than that element, and greater than that element
- We recursively sort those lists
- This gives us 3 lists:
  + A sorted list of things smaller than (or equal to) the head
  + The head
  + A sorted list of things greater than (or equal to) the head
- If we append these together in that order, the result will still be sorted
  + And contains everything from the original list

*** Quicksort Examples
#+begin_src racket :noweb strip-export :exports both
<<quicksort>>
(sortBy <= '(5 4 1 5 3 9 7))

(sortBy (lambda (x y) (<= (fst x) (fst y)))
      (list (pair 5 "a") (pair 4 "b") (pair 1 "c") (pair 9 "d")))

(sortBy (lambda (s1 s2) (<= (string-length s1) (string-length s2)))
        (list "goodbye" "hey" "hello" "a" "arithmetic" ))
#+end_src

#+RESULTS:
#+begin_src racket
'(1 3 4 5 5 7 9)
(list (values 1 "c") (values 4 "b") (values 5 "a") (values 9 "d"))
'("a" "hey" "hello" "goodbye" "arithmetic")
#+end_src

*** Polymorphic Combinators
- Combinators that are polymorphic are highly general
  + Ways to build new functions out of old functions
- Often used to build up arguments to map or filter

*** Function Composition
- For any two functions, we can chain them together
  + If their types agree
#+name: comp
#+begin_src racket
;; Written that way to match the symbol in math
(define (o [g : ('b -> 'c)]
           [f : ('a -> 'b)]) : ('a -> 'c)
  (lambda (x)
    (g (f x))))
;; (g (f x)) = ((o g f) x) for all x
;; Arguments in that order so that this equation looks nice
#+end_src

*** Example
#+begin_src racket :noweb strip-export :exports both
<<comp>>
(map (o (lambda (x) (* x 10)) add1)
   '(1 2 3 4))

(filter (o not empty?)
        (list '() '(1 2) '(3 2 1) '() '(1)))
#+end_src

#+RESULTS:
#+begin_src racket
'(20 30 40 50)
'((1 2) (3 2 1) (1))
#+end_src
- See type example on the board

*** Partial Application
- For functions that take multiple arguments, we can get a new function by providing only one argument
  #+name: curry
  #+begin_src racket
  (define (curry [f : ('a 'b -> 'c)]
                 [x : 'a])
          : ('b -> 'c)
    (lambda (y) (f x y)))
  #+end_src

- Can reverse order of arguments

  #+name: flip
  #+begin_src racket
  (define (flip [f : ('a 'b -> 'c)])
    : ('b 'a -> 'c)
    (lambda (bVal aVal) (f aVal bVal)))

  #+end_src

*** Example
#+begin_src racket :noweb strip-export :exports both
<<curry>>
<<flip>>
;; Gets (modulo x 2) for each x in the list
(map (curry (flip modulo) 2)
     '(1 2 3 4 5 6 7 8))
#+end_src

#+RESULTS:
#+begin_src racket
'(1 0 1 0 1 0 1 0)
#+end_src

*** Point Free Programming
- When you build functions using combinators instead of lambda, it's called
  /point free programming/
- Building programs becomes kind of like putting Lego together
- Generally, don't want to always use point-free programming
  + Sometimes the lambda is just clearer
- But can be easier to read in many cases
* Implementing Lambdas with Substitution and Dynamic Typing
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides012-dyntype.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Broad Strategy
*** Implementation Strategy
- In some ways, it's /easier/ to implement first-class functions with substitution than top-level functions
  + We can get rid of the whole list-of-definitions
  + Functions as a value: function carries a parameter name and a variable body
- Non-trivial parts:
  + Now we have /two/ possible kinds of values
  + Functions are not numbers
  + Need to implement *dynamic typing*
*** Syntax and Parsing
- ~{fun {SYMBOL} <expr>}~
  + ~{fun {x} body}~ is anonymous function with argument ~x~ and body ~body~
  + fun instead of lambda to distinguish Curly vs Plait
#+begin_src racket
(define (parse s-expr)
  (cond
    ....
    [(s-exp-match? `{fun {SYMBOL} ANY} s)
     (SurfFun (s-exp->symbol
              (first (s-exp->list
                        (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]))
#+end_src
*** Parsing Calls
- Same as before, but now we need to allow any expression in function position, not just symbols
#+begin_src racket
[(s-exp-match? `{ANY ANY} s)
     (SurfCall (parse (first (s-exp->list s))
               (parse (second (s-exp->list s))))]
#+end_src
*** The Value Type
#+begin_src racket
(define-type Value
  (NumV [num : Number])
  (FunV [arg : Symbol]
        [body : Expr]))
#+end_src

- The result of interpretation is called a /value/
  + Number, or a function
  + Function stores the info we need to call it
*** Lambdas in our ASTs
#+begin_src racket
(define-type Expr
  ....
  (Fun [arg : Symbol]
       [body : Expr]))
#+end_src
- Similar for ~SurfExpr~
- Notice that ~Fun~ and ~FunV~ have the /exact/ same fields
  + Functions /are/ values
  + A function is saying "here's a computation to do later", so once we've got a Lambda, there's no more evaluation to do
  + We'll see more of this for ~interp~
*** Values to Expressions
- We're going to need to substitute values into expressions
  + But ~subst~ works on expressions, not values
#+begin_src racket
(define (value->expr [v : Value]) : Expr
  (type-case Value v
             [(NumV v) (NumLit v)]
             [(FunV x body) (Fun x body)]))
#+end_src
- ~Value~ is /embedded/ in ~Expr~
  + Want  ~(interp (value->expr v))~ to produce ~v~
- Not actually doing any computation, just changing the constructors
  so the type checker is happy
- In a more sophisticated implementation language, we could make values a /subtype/ of expressions, but that's beyond this course
*** Substitution for Calls
- Needs to substitute in function and body
*** Substitution for Lambda
- Fun binds its variable
  + Similar to LetVar
- Don't substitute in a Lambda body if the variable we're replacing matches the function variable
  + Ensures that the function variable shadows any previous declarations
#+begin_src racket
(define (subst [toReplace : Symbol]
               [replacedBy : Expr]
               [replaceIn : Expr]) : Expr
  (type-case Expr replaceIn
  ....
  [(Fun x body)
     ;; Don't substitute if variable is shadowed
     (if (symbol=? x toReplace)
         (Fun x body)
         (Fun x (subst toReplace replacedBy body)))]
  ))
#+end_src
*** The Problem: Interpretation
- We want ~interp~ to produce a ~Value~
  + So that we can produce functions as the result of expressions
- Our previous interpreter assumed that ~interp~ always returned a number
- We need to introduce *dynamic type checking* in Curly-Fun
*** Aside: Type-Based Refactoring
- We can use the plait type inference to help us write our implementation
- Change ~interp~ to produce ~Value~ instead of ~Number~
- The type-checker sees an error
- Repeat until there are no type errors:
  + Go to the first type error
  + Change the code to have the right type
    - Wrap numeric results in ~NumV~
    - Perform dynamic type checks to extract fields
*** Dynamic Typing
- Curly now has two different types of things, ~FunV~ and ~NumV~
- It's possible
- /Dynamic type checking/ checks that the inputs to an operation are valid before running that operation
  + Make sure that Plus and Times are only given numbers
  + Make sure that the condition of ~if0~ is a number
  + Make sure the thing in a Call is actually a function
- /Dynamic/ because we check /while the program is running/
  + If we checked before it ran, it would be /static type checking/
*** Type Safety
- Racket is pretty safe
  + Can't write to arbitrary memory
- In other languages like C++, type errors (e.g. improper casts) can lead to safety issues, security bugs, etc.
- Curly is safe because Racket is, but we'll define our own notion of "type safety":
  + Want to raise an error with an informative message when a Curly program performs a type-unsafe operation, instead of a generic Racket error message
  + e.g. Dynamic type checks make sure that our interpreter, rather than Racket's built in functions, discover the error
  + Good practice for programming in less safe languages
*** Defining some helper functions
#+begin_src racket
(define (checkAndGetNum [v : Value]) : Number
  (type-case Value v
     [(NumV n) n]
     [else
     (error 'curlyTypeError
             (string-append "Expected Number, got function:"
                             (to-string v)))]))
(define (checkAndGetFun [v : Value]) : (Symbol * Expr)
  (type-case Value v
     [(FunV x body)
      (pair x body)]
     [else
     (error 'curlyTypeError
             (string-append "Expected Function, got number:"
                             (to-string v)))]))
#+end_src
- Lets us turn a Value into Number/Function
  + Better error-message than e.g. ~NumV-num~ gives
*** Evaluating Functions
#+begin_src racket
(define (interp expr)
  (type-case Expr interp
     ....
     [(Fun x body)
       (FunV x body)] ))
#+end_src
- Interp no longer needs a list of function definitions
  + Can use let + lambda for the same effect
- Nothing to do to turn function into a value
  + Just package up the data in the Value type
*** Calls
#+begin_src racket
(define (interp expr)
  (type-case Expr interp
  ....
    [(Call funExpr argExpr)
      (let* ([argVal (interp argExpr)]
             [funVal (checkAndGetFun (interp funExpr))]
             [funParam (fst funVal)]
             [funBody (snd funVal)]))
        (interp (subst funParam
                       (value->expr argVal )
                       funBody))] ))
#+end_src
- Mostly the same as for Curly-Fundef
  + Except don't have to look up the function body + param
- The thing we're calling might not be a Lambda /yet/
  + So we evaluate it recursively
  + Do a dynamic type check to make sure the result is a function, not a number

*** Capturing the environment
- Functions might contain /free variables/
  + Variables that are not bound/defined by the function itself
- Subst /will/ replace those variables when concrete values are given
  #+begin_src racket
  {letvar
     f {fun {x} {fun {y} {+ x y}}}
     {f 3}}
  #+end_src
  - For any ~x~, ~f~ produces another function that adds its argument to ~x~
  - ~x~ is /free/ in ~{fun {y} {+ x y}}~
  - Interp replaces ~f~ with the fun
  - Calling ~f~ with ~3~ replaces ~x~ with ~3~
    + Result: ~{fun {y} {+ 3 y}}~
    + e.g. The function that adds 3 to its argument
  - Substitution lets us build new functions at run time based on values to other functions

*** Fixing the rest of the interpreter
- Need to change operations to use Value instead of Number
  + Mostly just adding calls to ~checkAndGetNum~
  + See in-class file / Curly-Lambda for full details
- Don't need to change If0 branches or Let, since they don't do numeric operations
   + Can have an if that produces a function
#+begin_src racket
(define (interp expr)
  (type-case Expr expr
        [(If0 test thn els)
           (let ([testNum (checkAndGetNum (interp test))])
             (if (= 0 testNum)
                 (interp thn)
                 (interp els)))]))
#+end_src
*** A Helpful Higher Order Function
#+begin_src racket
(define (liftVal2 [f : (Number Number -> Number)]
                  [x : Value]
                  [y : Value]) : Value
  (let ([nx (checkAndGetNum x)]
        [ny (checkAndGetNum y)])
    (NumV (f nx ny))))
#+end_src
- Then can write:
  #+begin_src racket
(define (interp expr)
  (type-case Expr expr
     [(Plus l r)
       (liftVal2 + (interp l) (interp r))]
     [(Times l r)
       (liftVal2 * (interp l) (interp r))]))

  #+end_src
*** Our Language Is Now Turing Complete!
- Curly-Lambda can simulate every computer program ever written
  + Not counting syscalls, IO, networking, effects, etc.
- Just because we /can/ write an equivalent Curly-Lambda program, doesn't mean it's easy/succinct
- We can now write Curly-Lambda programs that run forever
#+begin_src racket
{letvar f {fun x {x x}}
  {f f}}
#+end_src
- Replaces ~f~ with ~{{fun {x} {x x}} {fun x {x x}}}~ calling itself
- Function call: takes body ~{x x}~, replaces ~x~ with argument ~{fun {x} {x x}}~
- Result is ~{{fun {x} {x x}} {fun {x} {x x}}}~, exactly what we started with!
- ~interp~ runs forever
*** A First Taste of Laziness
- How we implement ~if0~ really matters now
  + Code might run forever
  + Don't want to run code in the branch we don't take
- What if we did this?
  #+begin_src racket
  ;; BAD! Don't do this
  (define (interp expr
    (type-case Expr expr
        [(If0 test thn els)
        (let ([thenVal (interp thn)]
              [elseVal (interl els)])
          (if (= 0 (checkAndGetNum (interp test)))
                 thenVal
                 elseVal))])))
  (run `{if0 0
             {+ 1 1}
             {letvar f {fun x {x x}} {f f}}})
  #+end_src
- Loops because it evaluates the untaken branch

* Implementing Lambdas with Environments: Closures
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides013-closures.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Broad Goals
*** Overview
**** Goals
- Implement an interpreter for a Curly variant with functions
  + Add a Lambda feature
  + Allow functions to be taken or returned by functions
  + Allow function calls on arbitrary expressions, not just symbols
- Use Environments to make the implementation efficient
- Replicate the behaviour of the substitution-based interpreter
**** Key Concepts
- Definition of a closure
- Static and Dynamic Scope for first-class functions
** The Details
*** Substitution to Environmenst, Review
- Interpreter takes environment argument
  #+begin_src racket
  (define (interp [env : Env]
                  [expr : Expr])
          : Value ;; Was Number
    ....)
  #+end_src
- Function-calls evaluate body in environment containing argument
*** Core and Abstract Syntax
- Exact same as Curly-Lambda substitution version
#+begin_src racket
(define-type Expr
  ....
  (Fun [arg : Symbol]
       [body : Expr]))
#+end_src
- Goal is to interpret the same language, but with environments
*** A (Wrong) First Attempt: Values
- Define ~Value~ just like in substitution version
  +  Functions consist of their argument and the body to execute
#+begin_src racket
(define-type Value
  (NumV [num : Number])
  (FunV [arg : Symbol]
        [body : Expr]))
#+end_src
*** A Wrong First Attempt: Functions Interp
- As a first attempt, try building functions just like in substitition version
#+begin_src racket
(define (interp env expr)
  (type-case Expr interp
     ....
     [(Fun x body)
       (FunV x body)] ))
#+end_src
*** A Wrong First Attempt: Calls Interp
- Just like before
  + Evaluate argument to value
  + Evaluate function, make sure it's actually a function, and get its parameter and body
- Interpret function body in the environment with the parameter bound to the argument's value
#+begin_src racket
(define (interp env expr)
  (type-case Expr interp
  ....
    [(Call funExpr argExpr)
      (let* ([argVal (interp argExpr)]
             [funVal (checkAndGetFun (interp funExpr))]
             [funParam (fst funVal)]
             [funBody (snd funVal)]))
        (interp (extendEnv (bind funParam argVal)
                           env) ;;<------
                funBody))] ))
#+end_src
*** The problem
- With a lambda, there could have been many substitutions that were applied to its free variables
  + With substitutions, the variables get replaced in the lambda
  + With environments, the variables aren't replaced /until we interpret the body/
- When we actually go to interpret the body, we don't have the environment that the function was created in
  + Just the environment from the time of the call
- We've implemented *dynamic scoping* by accident!
*** The Solution: Closures
- A function should be /closed/ over its environment at the point it's created (interpreted)
- So we add an extra piece of data to the ~Value~ variant for functions: the environment at the time of creation
  + The combination of a function variable+body and an environment is called a *closure*
- Closures give environment interpreters the same behavior as substitution interpreters
*** Terminology
- /Static scope/ means a function never changes once it has been *defined*
  + We can still create functions dynamically
  + But once created they're static
*** The New Value Type
- Value version of functions contains an environment in addition to its variable and body
#+begin_src racket
(define-type Value
  (NumV [num : Number])
  ;; Like FunV but with an environment
  (ClosureV [arg : Symbol]
            [body : Expr]
            [env : Env]))
#+end_src
*** A New Dynamic Type Checker
- Same idea as ~checkAndGetFun~, just has an extra piece of data to retrieve
#+begin_src racket
(define (checkAndGetClosure [v : Value]) : ((Symbol * Expr) * Env)
  (type-case Value v
     [(ClosureV x body env)
      (pair (pair x body) env)]
     [else
     (error 'curlyTypeError
             (string-append "Expected Function, got number:"
                             (to-string v)))]))
#+end_src
*** Properly Interpreting Functions
- When we interpret a lambda, /package the current environment up with it/
  + This is what lets us dynamically create new functions
  + For top-level functions, this is the empty environment
#+begin_src racket
(define (interp env expr)
  (type-case Expr interp
     ....
     [(Fun x body)
       (ClosureV x body env) ;;<------
       ] ))
#+end_src
*** Properly Interpreting Calls
- When we call a function, extend /the environment that was packaged up with it/
  + Any free variables in the body get values from the place the closure was constructed

#+begin_src racket
(define (interp env expr)
  (type-case Expr interp
  ....
    [(Call funExpr argExpr)
      (let* ([argVal (interp argExpr)]
             [funVal (checkAndGetClosure (interp funExpr))]
             [funParam (fst (fst funVal))]
             [funBody (snd (fst funVal))]
             [funEnv (snd funVal)]))
        (interp (extendEnv (bind funParam argVal)
                           funEnv);;<------
                funBody))] )
#+end_src
*** Summary: Dynamic vs. Static Scope
- Free variables in a function body are variables that are
  not defined/bound in that function body
- Static scope gives free variables values from the environment when the function was /constructed/
- Dynamic scope gives variables values from the environment when the function was /called/
*** Example: Static Scope
#+begin_src racket
{letvar double {fun {x} {* x 2}}
  {letvar quadruple {fun {y} {double {double y}}}
    {letvar double 2
      {quadruple 3}}}}
#+end_src
- ~{fun {y} {double {double x}}}~ has one free variable, ~double~
  + Functions and variables are in /the same namespace/ in Curly-Lambda
- ~{fun {y} {double {double x}}}~ evaluates to closure
  + Body is ~{double {double x}}~
  + Env is ~double := {fun {x} {* x 2}}~
- Env at call:
  + ~double := 2~
  + ~quadruple := {fun {y} {double {double x}}}~
  + ~double := {fun {x} {* x 2}}~
*** Example: Static Scope ctd
#+begin_src racket
{letvar double {fun {x} {* x 2}}
  {letvar quadruple {fun {y} {double {double x}}}
    {letvar double 2
      {quadruple 3}}}}
#+end_src
- Call evaluates ~quadruple~ to closure
- Finally evaluates ~{double {double x}}~
  + In extended closure environment:
    - ~x := 3~
    - ~double := {fun {x} {* x 2}}~
- Result is 12
*** Example: Dynamic Scope
#+begin_src racket
{letvar double {fun {x} {* x 2}}
  {letvar quadruple {fun {y} {double {double x}}}
    {letvar double 2
      {quadruple 3}}}}
#+end_src
- ~{fun {y} {double {double x}}}~ evaluates to closure
  + Doesn't save environment
- Call evaluates ~{double {double x}}~
  + In extended /call site/ environment:
    - ~x := 3~
    - ~double := 2~
    - ~quadruple := {fun {y} {double {double x}}}~
    - ~double := {fun {x} {* x 2}}~
- Dynamic type error
  + Can't call 2 as a function
** But Professor, When Will I Ever Use This?
*** Static Scoping in the Wild
**** Python:
  #+begin_src python :exports both
  timesTwo = lambda x : 2 * x
  quadruple = lambda y : timesTwo(timesTwo(y))
  def mainFun(x):
      timesTwo = 2.0
      return quadruple(x)
  return mainFun(3)
  #+end_src

**** Result:
  #+RESULTS:
  : 12



*** Static Scoping in the Wild
**** JavaScript:
  #+begin_src js :exports both
  var timesTwo = function (x) { return x * 2 };
  var quadruple =
      function (x) {return timesTwo(timesTwo(x)) };
  function mainFun(x){
      var timesTwo = 2.0;
      return quadruple(x)}
  return mainFun(3)
  #+end_src

  #+RESULTS:
  : 12


**** Result:
  #+RESULTS:
  : 12



*** Async in JavaScript
- From the w3schools async tutorial
#+begin_src js
async function myFunction() {
  return "Hello";
}
myFunction().then(
  function(value) {myDisplayer(value);}
);
#+end_src
- ~myFunction.then~ is a higher order function
  + Takes in another function as an argument
- They call the function argument the /callback/
- ~function(value)~ is just the Javascript syntax for lambda
  + Dynamically creates the function that is run when ~myFunction~ actually runs
- Concurrency in JS is mostly just syntactic sugar for lambda/higher-order functions

*** And More
- Swift "Closures" are just lambdas
  #+begin_src swift
  names.sorted(by:
    { (s1: String, s2: String) -> Bool
        in return s1 > s2
    } )
  #+end_src
- C++11 added anonymous functions
  #+begin_src c++
  sort(V.begin(), V.end(), [](auto& a, auto& b) -> bool
  {
     return a > b;
  });
  #+end_src
- Java 8 added anonymous functions
  #+begin_src java
  Arrays.sort(arr,
    (String a, String b) ->
              a.length() - b.length());
  #+end_src
- This is all just lambda with different syntax

* Midterm Review
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides014-midterm-review.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Overview
*** The Road So Far
- Functional programming
  + Recursion and datatypes
  + Higher-order functions and lambdas
- Interpreters
  + Parsing basics and syntax trees
  + Arithmetic via recursion on the AST
  + Adding conditionals: If0
  + Adding syntactic sugar
    - Now have Surface AST and Core AST
    - ~elab~ translates from surface to core
    - Expresses some features in terms of other ones
  + Adding functions
    - Substitution
    - Environments
  + Adding variables
    - Let via substitution
    - Let via environment extension
  + First-class functions
    - Dynamic typing
    - Closures and environments
**  Functional Programming Concepts
*** Functional Programming
- Functions /in the mathematical sense/
  + Same input always produces same output
- Variables are /immutable/
  + Once a variable has a value, it keeps that value for its entire scope
- The main method of iteration/repetition is recursion
  + Not loops
  + Explicit recursion: a function calling itself on different (smaller) arguments
  + Higher-order functions: capture patterns of recursion that can be re-used many times
*** Programming With Recursion 1: Shape
- Identify the shape of the problem
  + Types of inputs
  + Types of outputs
  + Other assumptions not expressible with types
    - e.g. Can we assume numbers are integers? Positive? etc.
    - e.g. Can we assume a list is non-empty
- Now you can write tests, since you know what valid inputs are
*** Programming With Recursion: Template
- What are the cases you have to handle?
  + Numbers: ~0~ vs. ~(+ n 1)~
  + List: ~empty~ vs. ~(cons h t)~
  + Datatype: each constructor
- What are the sub-values for each case?
  + List: head and tail for cons case
  + Datatype: fields for that constructor
- Write a template that looks at the input and has a placeholder for each case
  + Numbers: branch using ~if~ or ~cond~
  + Lists or datatype: branch using ~type-case~
*** Programming With Recursion: Base vs Recursive Case
- Figure out which cases are base cases and which are recursive cases
  + Recursive case has a sub-value of input
  + Might be many base cases for datatype
    - E.g. in ~Expr~, ~Var x~ and ~NumLit n~ are both base cases
- For the base case, figure out the solution for that case
  + Depends on the problem you're looking at
    - E.g. "If my input is 0, what should ~f 0~ be?"
    - E.g. "If my list is empty, how do I apply a function to each element in it?"
*** Programming With Recursion: Recursive Calls
- Figure out what recursive calls you can make in the recursive cases
- You can ALWAYS assume that the recursive call will produce the correct result
  + Treat like a magic box that gives the right answer, but only for smaller values
- Process:
  + If a sub-value has the same type, can definitely use it as argument to recursive call
  + Figure out values for other arguments
    - Problem dependent
    - E.g. What ~env~ do we pass in ~interp~?
  + Might be helpful to use ~let*~ to store results of recursive calls in variables
    - Can always delete if you don't end up using them in the solution
-
*** Programming With Recursion: Putting It Together
- Look at what you have in scope
  + Fields/sub-values of the input
  + Results of recursive calls
  + Other arguments
- Look at the types
  + Lets you know what you have, and what you need build things together
- If you don't have what you need, ask:
  + Could I make a helper function to get what I need?
    - Helper could also be recursive
- Compute the result you need for the recursive cases
  + Problem-specific
*** Constructing a value of a given type
- Look at the type of the thing you're trying to produce
- You must build it using one of:
  + A variable that is in scope
  + A literal/constant
    - e.g. ~4~ or ~#t~ or ~"hello"~
  + A function or constructor application
    - Each argument to the function must then be provided
    - Look at their types and repeat this process
- Which you choose depends on what you're trying to do
** Higher Order Functions
*** Designing Higher Order Functions
- The process is the exact same
  + Except sometimes you have inputs or outputs that are functions
- Might use recursion if your input is recursive data
  + e.g. List or datatype
- Might not
  + e.g. If you're writing ~comp : (('b -> 'c) ('a -> 'b) -> ('a -> 'c))~
    there's nothing to deconstruct/recur on, so you just build the solution directly
- Same advice applies:
  + Look at the types of what's in scope
  + Look at what you can build using what's in scope
- The way to build a function is with ~lambda~

* Generative Recursion and Tail Recursion
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides015-tailrec.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Broad Goals
*** Overview
- Objectives
  + Iteratively building solutions to problems in functional languages
  + Implementing recursive procedures efficiently
  + Capturing this pattern of recursion as a higher-order function
- Key Concepts
  + Generative recursion
  + Tail-calls
  + Tail-call elimination
  + Folds
** Generative Recursion
*** The Problem
- Some problems don't obviously map to the style of recursion we've seen so far
  + Or do, but not efficiently
- Especially problems that are about incrementally updating a value
  + No good way to talk about "the result so far"
- e.g. What's the recursive version of:
  #+begin_src c++
  int x = startVal;
  for (int i = 0; i < n; i++)
  {
    x = f(x);
  }
  #+end_src
*** Example: Reversing a List The Naive Way
#+name: reverse-slow
#+begin_src racket :exports both
(define (reverse [xs : (Listof 'a)]) : (Listof 'a)
  (type-case (Listof 'a) xs
    [empty empty]
    [(cons h t)
       (append (reverse t) (list h))]))
(reverse '(1 2 3))
(reverse '("hello" "goodbye"))
#+end_src

#+RESULTS: reverse-slow
#+begin_src racket
'(3 2 1)
'("goodbye" "hello")
#+end_src

- Reversing the empty list produces the empty list
- Reversing a list with one element means
  + Reversing the tail of the list
  + Putting the first element at the end of the new list
- $\mathcal{O}(n^2)$: Each ~append~ has to walk through the whole list
*** Reverse: What we want (conceptually)
- Start with an empty list
- Pop an element off the first list, then add it to our result list so far
- When reach the end, have a reversed list
*** An efficient reverse
#+begin_src racket
(define (reverseHelper [xs : (Listof 'a)]
                       [listSoFar : (Listof 'a)]) : (Listof 'a)
  (type-case (Listof 'a) xs
    [empty
       listSoFar]
    [(cons h t)
       (reverseHelper t (cons h listSoFar))]))
(define (reverse xs) (reverseHelper xs '()))
#+end_src

- Helper function
  + Base case: finished, produce the list we've built so far
  + Recursive case: keep building, but on the tail of the list
    - Call with head appended to ~listSoFar~
- Main function calls the helper with the start value
  + Empty list ~'()~
*** General Template
**** To write ~f : (Ty1 Ty2 ... TyN -> ReturnTy)~
+ Write a helper function with one extra argument
  - Extra argument called the /accumulator/
    + Often named ~accum~
  - Has same type as return type
    + ~fHelper : (Ty1 Ty2 ... TyN ReturnTy -> ReturnTy)~
+ Helper function is recursive
  - Base case: return the accumulator
  - Recursive case: call the helper recursively on the sub-value
    + Compute an updated value for the result so far
    + Pass it as the accumulator for the recursive call
+ Last step: ~f~ calls helper with initial accumulator value
*** The Call Stack
- In Racket (or any language), when we make a function call, we need to know what to do with the result
  + In C/C++: where to execute after return is computed
  + Keep track of the expression we'll plug the result into
    - Note: We don't have a stack in Curly (yet) because our interpreter is written such that the Racket stack keeps track of where to return.
- Each function call pushes onto the call stack, pops when it returns
  + You've probably seen this when you get an error message in e.g. Python
- Stack contents
  + Body of function being currently computed
  + Environment for that body
  + Position in expression that's waiting for the result of this function
    -  Called the /continuation/
*** Stack Overflow
- If the call stack gets too large, a /stack overflow/ can be triggered
  + When the memory allocated for the stack is exceeded
- Typically the stack has much less space than the heap (dynamically allocated memory)
  + Specifics depend on the implementation of your language
*** Example
#+begin_src racket
(define (g y z) (+ y z))
(define (f x)
  (cons (g x 1) '()))
(f 3)
#+end_src
- Start:  stack top empty
- Call ~f~:
  + Push body ~(cons (g x 1) empty)~, env ~x := 3~, continuation is ~END_OF_PROGRAM~
- Call ~g~
  + Push body ~(+ y z)~, env ~y := 3, z := 1~, continuation is ~(cons [] '())~
    - ~[]~ shows where the result of the body is used
- Return (pop) : plug ~4~ in place of ~[]~ to get ~cons 4 '()~
- Return (pop), see ~END_OF_PROGRAM~ marker, produce ~'(4)~ as result
*** Returning a Function Call
- Slightly different example
#+begin_src racket
(define (g y z) (+ y z))
(define (f x)
  (g x 1))
(f 3)
#+end_src
- Start:  stack top empty
- Call ~f~:
  + Push body ~(g x 1)~, env ~x := 3~, continuation is ~END_OF_PROGRAM~
- Call ~g~
  + Push body ~(+ y z)~, env ~y := 3, z := 1~, continuation is ~[]~
    - Result of ~g~ is value of ~f~'s body
- Return (pop) : plug ~4~ in place of ~[]~ to get 4
- Return (pop), see ~END_OF_PROGRAM~ marker, produce ~4~ as result
*** What's The Difference?
- In the first example, we had to take the result of the call to ~g~ and incorporate it into the result of ~f~
  + By adding it as the first field of ~cons~
- In the second example, the result of ~g~ /was/ the result of ~f~
  + We never needed ~x~ in the environment after making the call to ~g~
  + We never need the body of ~f~ after making the call to ~g~
    - All the body of ~f~ tells us is to compute the body of ~g~
- The Racket/Plait interpreter can just change the body and env on the stack, /without pushing to it/
  + Mutation $\to$ fast
*** Tail Calls
- An expression is in *tail position* if it is
  + The body of a function
  + The branch of a conditional (if, type-case, etc.) that was in tail position
- A function call in tail position is a *tail call*
- A function is NOT a tail call if it is
  + An argument to another function or constructor
- Tail calls can be implemented as /jumps/ and /mutation/
  + Don't need to add to the stack
*** Tail Recursion
- Tail recursion: when *all recursive calls in a function definition are tail calls*
- Generative recursion (as described above) /is/ tail recursion
- Tail recursive functions can be optimized into a loop
  + No need to change the stack
  + Recursive call $\to$ update parameters then jump
  + Constant memory usage
  + Less overhead
*** Example: List Length in Constant Space
#+begin_src racket
(define (fast-length-helper [xs : (Listof 'a)]
                            [accum : Number])
  (type-case (Listof 'a) xs
    [empty accum]
    [(cons h t)
       (fast-length-helper t (+ 1 accum))]))
(define (fast-length xs) (fast-length-helper xs 0))
#+end_src
- Instead of computing the result directly, we incorporate the "result so far" into the new information from the non-recursive arguments
- We keep computing by calling ~fast-length-helper~ recursively
  + Parameter gets smaller
  + Accumulator gets more information
- Recursive call is tail call
- Won't stack overflow, even on large arguments
*** Live Example: Slow and Fast Factorial
- See Racket in lecture
*** A Note On Terminology
- *Generative recursion* is when recursion works by building up (generating) a solution as an extra parameter, and returning that parameter in the base case
- *Tail recursion* is when all recursive calls in a function are tail calls
- Many examples we'll see in this course of tail recursion are also generative recursion, and vice versa
  + Some counter-examples, e.g. ~foldr~ that we'll see soon
*** Tail Recursion and While Loops
- We can relate tail recursion to while loops in imperative languages
#+begin_src c++
x = initialValue;
while (test(x)){
 x = f(x);
}
return g(x);
#+end_src
- Is equivalent to
#+begin_src  racket
(define (helper x)
  (if (test x)
      (helper (f x))
      (g x)))
#+end_src
- Updating multiple variables $\to$ multiple arguments to ~helper~
*** Implicit vs. Explicit State
- Once again, we see that functional languages can express the same patterns as imperative language
- We can still express stateful computations in functional languages, but it's /explicit state/
  + You can tell what state there is by looking at the type of a function
  + Nothing is hidden from the
- Bugs in code are often due to subtle interactions between mutable states
  + Especially with parallelism/concurrency
- The functional style means that no state is hidden
  + Easier to debug state problems
    - By hand, or with tools/linters
** Abstracting Generative Recursion
*** Objective
- Goals
  + To see how the pattern of generative recursion on lists can be represented concretely as a higher order function
- Key Concepts
  + ~foldl~ and ~foldr~
*** Higher-Order Genrative Recursion: Folds
- Recall: higher-order polymorphic functions let us turn design patterns into functions
  + e.g. ~map~ for "do this to each element of a list"
- Generative recursion is no exception
*** Foldl
#+name: foldl
#+begin_src racket
(define (foldl [f : ('a 'b -> 'b)]
               [accum : 'b]
               [xs : (Listof 'a)]) : 'b
  (type-case (Listof 'a) xs
    [empty
      accum ]
    [(cons h t)
       (foldl f (f h accum) t)]))
#+end_src
- Generative recursion on a list as a function
- Name ~foldl~ means "fold left"
  + Processes elements in order
- If list empty, gives whatever the initial ~accum~ was
- If not empty, uses ~f~ to update the ~accum~ based on the first element of the list
  + Then processes the rest of the list with a recursive call
- Tail recursive, so fast and takes constant space
*** Example: Reverse using folds
#+begin_src racket :noweb strip-export :exports both
<<foldl>>
(define (fold-reverse [xs : (Listof 'elType)]) : (Listof 'elType)
  (foldl (lambda (elem accum) (cons elem accum))
         '()
         xs))
(fold-reverse '(1 2 3))
#+end_src

#+RESULTS:
#+begin_src racket
'(3 2 1)
#+end_src
- ~'a~ is ~'elType~, ~'b~ is ~(Listof 'elType)~
- Update function type is ~('elType (Listof 'elType) -> (Listof 'elType))~
- Initial accumulator is empty list, since we start with nothing
- Update function adds the current element to the front of the list we've built so far
*** Reasoning with foldl
 - ~(foldl f init '(a b c d))~ gives:
   +  ~(f d (f c (f b (f a init))))~
 - Similar to normal recursion:
   + Assume that ~accum~ has the correct result so far
   + Find the ~f~ that incorporates the next element of the list into the new ~accum~
 - For ~fold-reverse~
   + Assume that ~accum~ has the correct reversal of the list we've seen so far. How do we incorporate the next element?
     - We add it to the front, since it's the last of all elements we've seen so far, so the first in the reversed list
     - Recursive call says "keep processing for the rest of the list"
*** Non-tail Folds
#+begin_src racket
(define (foldr [f : ('a 'b -> 'b)]
               [init : 'b]
               [xs : (Listof 'a)]) : 'b
  (type-case (Listof 'a) xs
    [empty
      init ]
    [(cons h t)
       (f h (foldr f init t))]))
#+end_src
- Like foldr, but processes the list right-to-left
- ~(foldr f init '(a b c d))~ gives ~(f a (f b (f c (f d init))))~
- Reasoning the exact same, except we assume the argument to ~f~
  has the accumulator for all elements /after/ the current element
- Generally ~foldl~ is faster
*** List Recursion, Once And For All
- ~foldr~ is the higher-order function version of pattern matching on lists
  + Give an empty case (initial value)
  + Give a function that incorporates head of the list with the recursive result on the rest of the list
- ~foldl~ is the higher-order function version of generative recursion on lists
  + Give an initial accumulator
  + Give a way to update the accumulator for each element of the list
- These two functions can replace (nearly) all pattern matching/recursion on lists
- Examples (see lecture Racket file)
* Currying and the Lambda Calculus
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides016-currying.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Overview
*** Objectives
- Learning Goals
 - To learn how multi-argument functions can be
   desugared into single-argument functions
   + Curly-Curry
 - To see that /everything/ can be desugared into single-argument functions
   + by learning about the Lambda Calculus
- Core Concepts
  + Currying
  + Lambda Calculus
** Currying
*** Executing a multiple-argument function
- Say we allow ~{lambda {x y z} {+ x {* y z}}}~ in Curly
- How can we interpret a call to this function?
  + Evaluate the body with either
    - ~x,y,z~ replaced by concrete argument values (substitution)
    - ~x,y,z~ bound to concrete values in an environment
*** Achieving this: Currying
- We can achieve this with nested lambda expressions
#+begin_src racket
{let f {fun {x} {fun {y} {fun {z} {+ x {* y z}}}}}
  ....}
#+end_src
- To call, we do nested calls
#+begin_src racket
{{{f 1} 2} 3}
#+end_src
- Step by step:
  + ~f 1~ produces ~{fun {y} {fun {z} {+ 1 {* y z}}}}~
  + Calling that on 2 produces ~{fun {z} {+ 1 {* 2 z}}}~
  + Calling that on 3 produces ~{+ 1 {* 2 3}}}~
    - Exactly what we want for ~{f 1 2 3}~
*** Definition
- The approach of simulating multiple-argument functions with nested single-argument functions is called *Currying*
  + Named after Haskell Curry, and American logician
    - Also the namesake of the Haskell programming language
- A function written in this style is /curried/
*** Desugaring with Currying
- We can add multiple-argument functions to our Surface Language /without/ changing
  the core language
  + Handle in ~elab~
  + Doesn't matter if do substitution or environment-based version, translation is the exact same
*** AST for Multi-Argument Functions
#+begin_src racket
(define-type SurfExpr
....
 (SurfFun [xs : (Listof Symbol)]
          [body : SurfExpr]))
 (SurfCall [fun : SurfExpr]
           [args : (Listof SurfExpr)])
#+end_src
- Functions now take a list of variables
- Calls now take a list of arguments
*** Elaborating Multi-Argument Functions
- Use recursion to iterate through the list
  #+begin_src racket
  (define (elab [surfExpr : SurfExpr])
    (type-case SurfExpr surfExpr
               ....
     [(SurfFun xs body)
       (type-case (Listof Symbol) xs
         [empty
           (elab body)]
         [(cons x rest)
           ;; Could also do with a helper fn
           (Fun x (elab (SurfFun rest body)))])]))

  #+end_src
- No arguments: just produce the body
- At least one argument: curry the rest of the arguments, and wrap the result in a lambda
*** Multi-Argument Calls with Tail Recursion
#+begin_src racket
  (define (callHelper [args : (Listof SurfExpr)]
                      [accum : Expr]) : Expr
    (type-case (Listof SurfExpr) args
        [empty accum]
        [(cons arg rest)
           ;; tail recursion
           (callHelper rest (Call accum (elab arg)) )]))
  #+end_src
- Given a list of argument to apply, build up one giant expression with nested calls
***  Building The Entire Call
#+begin_src racket
  (define (elab [surfExpr : SurfExpr])
    (type-case SurfExpr surfExpr
               ....
     [(SurfCall funExpr args)
        (callHelper args (elab funExpr))]))

#+end_src
*** A Word of Warning
- Plait does /not/ use currying by default
  + Multiple argument functions are /not/ desugared into single-argument ones
- We can convert between curried and uncurried functions with combinators
  + See lecture on Higher Order Functions
- A 0-argument ~(lambda () e)~ is /NOT/ the same as ~e~ in Plait
  + But it is in Curly, if we use this desugaring
*** Another Desugaring: Let
- Recall that ~letvar~ let us define a local variable to have the value of some expression, that we could then use to build another expression
- We can make ~letvar~ syntactic sugar using lambda
#+begin_src  racket
  (define (elab [surfExpr : SurfExpr])
    (type-case SurfExpr surfExpr
               ....
     [(SurfLetVar x xExpr body)
        (Call (Fun x (elab body))
              (elab xExpr))]))
#+end_src
- Define a function whose body is the body of the ~letvar~
- Immediately call it with the value we're giving to the defined variable
- Letvar: executes the body in the environment extended with the variable's value
  + This does the exact same thing
** Lambda The Ultimate

*** Functions As Sugar
- So far we've seen that single argument functions can simulate
  + Multi-argument functions
  + Local variable definitions
- What else can se simulate?
- *NOTE* I won't ask about the following desugarings on an exam
  + But they're an important introduction to the "science" of computer science
    and the "mathematics" of informatics
*** The Smallest Language We Can Imagine
#+begin_src racket
(define-type UTLC
  ;; A variable
  (Var [x : Symbol])
  ;; Function application (call)
  (App [fun : UTLC]
       [arg : UTLC])
  ;; Anonymous function (lambda)
  (Lam [param : Symbol]
       [body : UTCL]))
#+end_src
- Stands for "Un-Typed Lambda Calculus"
- All you can do is define an anonymous function (lambda) or call a function (application)
- *The Untyped Lambda Calculus is Turing Complete*
  + Any program you can write, you can write an equivalent UTLC Program
*** Interpreting the UTLC
- Works just like we've seen so far
  + ~Lam~ is like ~Fun~
  + ~App~ is like ~Call~
- Substitution version
#+begin_src racket
(define (interpUTLC [e : UTLC] : UTLC)
  (type-case UTLC e
    [(App fun arg)
       (type-case (interpUTLC fun)
          [(Lam x body)
             (interpUTLC (subst x arg body))]
          [else (error 'x "Undefined variable")])]
    ;; Function and variables don't do any computation,
    ;; they just return themselves
    ;; Could have variables return an error,
    [else e]))
#+end_src
- Can also do with environments, like Curly-Lambda-Env
*** Booleans
- Note: I'll write the desugarings as functions, rather than with ~elab~, just to keep things self contained
- You can imagine these functions as constructors we'd use for the surface syntax, that produce ~UTLC~ directly
#+begin_src racket
(define True
  (Lam 'x (Lam 'y (Var 'x))))
(define False
  (Lam 'x (Lam 'y (Var 'y))))
;; curried (test thenCase elseCase)
(define (If test thenCase elseCase)
  (App (App test thenCase) elseCase))
#+end_src
- If we give ~If~ the boolean ~True~ it produces the then-case
- If we give ~If~ the boolean ~False~ it produces the else-case
*** Numbers
- Define $n$ to be the function that takes in another function and an argument, and applies it $n$ times
  +  $\lambda f \lambda x \ldotp f (f (f ... (f x)))$
#+begin_src racket
(define Zero
  (Lam 'f (Lam 'x (Var 'x)))) ;; Function that returns its argument
;; Add one to a number
(define (Add1 n)
  (Lam 'f (Lam 'x) (App (Var 'f) (App (App n f) x))))
(define (Plus m n)
  (Lam 'f (Lam 'x) (App m (App (App n f) x))))
#+end_src
*** Pairs
- You can view a pair as a function that takes in a boolean and returns either the first or second value depending on that boolean
#+begin_src racket
(define (Pair x y)
  (Lam 'z (If (Var 'z) x y)))
(define (Fst pr)
  (App pr True))
(define (Snd pr)
  (App pr False))
#+end_src
*** Recursion: The Y Combinator
- Not the startup funder
- $\lambda f \ldotp (\lambda x \ldotp f\ (x\ x)) (\lambda x \ldotp f\ (x\ x)))$
#+begin_src racket
(define Y
  (Fun 'f (App (Fun 'x (App f (App x x)))
               (Fun 'x (App f (App x x))))))
#+end_src
- Takes a function ~f~ with an extra parameter ~self~
- Makes a new function where each call to ~self~ is replaced by a call to ~f~
- You don't need to know the details of how this work, just that it's possible to
  do recursion in the UTLC
- Once we have recursion, we have loops
* Store Passing and Boxes
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides017-box.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Overview
*** Store Passing Interpreters
- Objectives
  + Understand boxes as an abstraction for mutable state
  + Implement an interpreter for a language with mutable state
    - Where the implementation language does /not/ have mutable state
  + See how Racket can extend its own syntax
- Key Concepts
  + Mutable state
  + Store data structure
  + Store passing
  + Boxes
  + Macros
** Curly-Box: A Language with Mutation
*** Boxes
*** Expressions vs. Statements
- *Expression:* a program or program fragment that is meant to be evaluated
  + Produces a value
  + e.g. Function arguments in C++/Python are expressions
  + Might have side-effects
- *Statement*: a program fragment that is meant to be executed
  + ~if~, loop-bodies, function bodies are all statements in Python/C++
  + e.g. Had to explicitly ~return~ or use assignment to produce a value from a statement
- All of our Curly languages (and Racket) are /expression oriented languages/
  + No notion of statement
  + Syntax consists of nested expressions
    - If0 branches: expressions
    - Function bodies: expressions
*** Sequencing
- Expression-oriented version of a statement
- ~{begin <expr> <expr>}~
  + Called ~seq~ in the textbook
- Evaluates the first expression /then discards the result/
  + Only useful if the first expression has side effects
- Then evaluates the second expression
- The value of the second expression is the value of the whole ~begin~ expression
*** Boxes
- Kind of like C++ References
- Pointers, but with no notion of pointer arithmetic
- A box denotes a location in the store (memory, etc.)
- Copies of a box refer to the same part of memory
  + So changes to that part are seen by /all/ copies of that box
*** Boxes in Curly-Box
- ~{box <expr>}~
  + Allocates a new box in the store with the
  + Like C++ ~void* x = new int; *x = expr;~
- ~{unbox <expr>}~
  + Evaluates the expression to a box
    - dynamic type error if not a box
  + Produces the value for that box's location in memory
  + Like C++ ~*x~;
- ~{set-box! <expr> <expr>}~
  + The ~!~ indicates that the form has a side effect
    - Just a convention, ~!~ is a normal character in Racket/Curly
  + Evaluates the first expression to a box
  + Evaluates the second expression
  + Stores that value in the box's location in memory
  + Produces that value as the result
    - Other design choices are possible for the result
  + Like C++ ~*x = expr;~
*** Example
#+begin_src racket
{letvar x {box 3}
  {letvar y x
  {begin {set-box! y 10}
    {unbox x}}}}
#+end_src
- Allocates a new box, with the value 3
- The variable ~x~ is given the value of that box
- The variable ~y~ is given the value of ~x~
  + e.g. the value of the box
- We write 10 to /the location that ~y~ points to/
  + This is the same location that x points to
- We produce the value from wherever ~x~ points
  + 10, since we updated its value
** Interpreting Boxes
*** Semantics
- We /could/ just use Racket mutation to implement boxes
  + But we're not going to
- Recall: when we define a functional language, we get equations about the functions we define
  + e.g. ~(interp (Plus x y))~ is /mathematically equal/ to ~(+ (interp x) (interp y))~
- Our interpreters aren't just implementations
  + They're /specifications/ for the language
    - Semantics
  + Equations we can use to reason about program behaviour
- By using a purely functional approach, we define a semantics for Curly, even if it has mutation
- The semantics is informal, but still a useful tool for /understanding/ stateful programs and languages
*** The Store
- Data structure modelling memory
#+begin_src racket
(define-type-alias Location Number)

(define-type Storage
  (cell [location : Location]
        [val : Value]))

(define-type-alias Store (Listof Storage))
(define mt-store empty)
#+end_src
- Store is a list of location-value pairs
  + Super inefficient version of a key-value store
    - e.g. Python dictionary with integer keys
  + Interface is what matters
*** Store Operations: override-store
#+begin_src racket
;; (Storage Store -> Store)
(define override-store cons)
#+end_src
- Creates /a new store/ that has the given value at the given location
  + If something was in that location, the new value overwrites it
  + In our implementation, this happens by adding the new value to the start of the list, so a search will always find it first
- Original store is unchanged
  + Purely functional /implementation language/
*** Store Operations: new-loc
#+begin_src racket
(define (new-loc [sto : Store]) : Location
  (+ 1 (max-address sto)))

(define (max-address [sto : Store]) : Location
  (type-case (Listof Storage) sto
   [empty 0]
   [(cons c rst-sto) (max (cell-location c)
                          (max-address rst-sto))]))
#+end_src
 + Get a new ~Location~ that does not yet have a value in the store
   - ~max-address~ is a helper that enables this
 + Used with ~override-store~ to extend a store to a new one with an additional location
*** Store Operations: fetch
#+begin_src racket
(define (fetch [l : Location] [sto : Store]) : Value
  (type-case (Listof Storage) sto
   [empty (error 'interp "unallocated location")]
   [(cons c rst-sto) (if (equal? l (cell-location c))
                         (cell-val c)
                         (fetch l rst-sto))]))
#+end_src
- Get the value at the given location
  + Finds the first one in the list e.g. from the most recent ~store-override~
*** A Store Passing Interpreter
- Recall how with generative recursion, we added an extra parameter to our function to simulate something being updated
- To interpret a language with mutable state, we'll do something similar
  + Add a ~Store~ parameter to ~interp~
  + Make ~interp~ produce both a ~Value~ and an updated ~Store~
#+begin_src racket
(define-type Result
  (v*s [v : Value] [s : Store]))
(define (interp [env : Env]
                [e : Expr]
                [sto : Store]) : Result
  ....)
#+end_src
- Custom pair-type for value-store pairs
- ~interp~ takes an expression, and environment, and a store
*** Updating The Interpreter: Plus
#+begin_src racket
(define (interp [env : Env]
                [e : Expr]
                [sto : Store]) : Result
  (type-case Expr e
   [(Plus l r)
     (type-case Result (interp l env sto)
       [(v*s v-l sto-l)
        (type-case Result (interp r env sto-l)
          [(v*s v-r sto-r)
           (v*s (liftVal2 + v-l v-r) sto-r)])])]
#+end_src
- Interp the left, getting its value and store
- Interp the right /using the new store from the left/
- Do the addition, /then return the resulting store from the right/
  + Design choice: which operand we eval first makes a difference
*** Aside: Racket Macros
- Racket lets you define your own syntactic sugar
  + Add or rewrite Racket syntax
- These are called macros
- C++ has /textual macros/
  + Just inserts a string into the text of your source file
- Racket has /syntactic macros/
  + Actually lets you write functions that run at compile-time and inspect the syntax given
- ~define-type~ and  ~type-case~ are both Racket macros
- The entire ~plait~ type system is implemented with Racket macros
*** A Macro for Interpreting with Stores
#+begin_src racket
(define-syntax-rule
  (with [(v-id sto-id) call]
    body)
  (type-case Result call
    [(v*s v-id sto-id) body]))
#+end_src
- I won't ask you to write a macro on an exam
- I might check whether you know that
  + Macros extend the syntax of a language using the language itself
  + Macros are code that is run at compile-time
*** Using Our Macro
#+begin_src racket
(define (interp [env : Env]
                [e : Expr]
                [sto : Store]) : Result
  (type-case Expr e
    [(Plus l r)
     (with [(v-l sto-l) (interp l env sto)]
       (with [(v-r sto-r) (interp r env sto-l)]
         (v*s (liftVal2 + v-l v-r) sto-r)))]
#+end_src
- Much more succinct: call interp, and immediately give a name to the store and value we get as a result
- Updating all the other cases is similar
  + See in-class Racket if time permits
*** Boxes as Values
- We represent boxes using locations in the store
  + What value is in the box depends on the current store
#+begin_src racket
(define-type Value
  (ClosureV [arg : Symbol]
            [body : Expr]
            [env : Env])
  (NumV [num : Number])
  (BoxV [loc : Location]))
#+end_src
*** Interpreting Box
#+begin_src racket
[(Box a)
   (with [(v sto-v) (interp a env sto)]
     (let ([l (new-loc sto-v)])
       (v*s (BoxV l)
            (override-store (cell l v)
                              sto-v))))]
#+end_src
- Interpret the value we're putting in the box
  + And get the store from this interpretation
- Create a new store that has the value at a new address
- Return the box with the new location
  + Return store is the store with the new location and value

*** Interpreting Unbox
#+begin_src racket
[(Unbox a)
     (with [(v sto-v) (interp a env sto)]
       (type-case Value v
         [(BoxV l) (v*s (fetch l sto-v)
                        sto-v)]
         [else (error 'interp "not a box")]))]
#+end_src
- Interpret the expression to a value
  + Get the value and the store from this, since it might have had side effects
- Check if the value is a Box
  + Type error otherwise
- Get its location, and produce whatever value was at that location
  + With the store from evaluating the box
*** Interpreting Set-box!
#+begin_src racket
[(Setbox bx val)
     (with [(v-b sto-b) (interp bx env sto)]
       (with [(v-v sto-v) (interp val env sto-b)]
         (type-case Value v-b
           [(BoxV l)
            (v*s v-v
                 (override-store (cell l v-v)
                                 sto-v))]
           [else (error 'interp "not a box")])))]
#+end_src
- Interpret the box to a value
  + Get the store from this execution
- Interpret the expression to be stored to a value
  + In the store we previously computed, getting a new store
- Check that the box value is actually a box
- Return the other value, /in the new store with the box location overwritten/
*** Interpreting Begin
#+begin_src racket
[(Begin l r)
     (with [(v-l sto-l) (interp l env sto)]
       (interp r env sto-l))]
#+end_src
- Evaluate the first expression /but do nothing with the value/
  + Just get the store that's the result of evaluating it
- Evaluate the second expression /in the store the first returned/

*** Stores vs Environment
- Environments enable /static scope/
  + Follow the stack like structure of function calls
  + When we return from a function call, we keep evaluating in the old environment
- Stores are inherently dynamic
  + We /want/ them to always take the value from the point ~unbox~ is executed
  + Linearly threaded through the program
  + Once we've updated a store (by generating a new one), /we never use the old store again/
    - ... until we implement more advanced features e.g. undo, backtracking
* Mutable Variables
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides018-mutvar.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Curly-Mutvar
*** Overview
- Learning goals
  + To interpret a language where variables can change values (mutate)
  + To understand the design choices around functions in such a language
- Key concepts
  + Pass-by-reference vs. Pass-by-value
*** Identifiers vs Variables
- Until now, a variable denoted a /value/
  + In a given environment
- They didn't really ever vary
  + Except between different function calls
- To allow variables values to change, we can make one simple change:
  + *Keep locations instead of values in the environment*
  + Then each variable refers to a single store location, whose value can change
*** Bindings with mutable variables
- Each binding associates a symbol with a /location/
  #+begin_src racket
(define-type Binding
  (bind [name : Symbol]
        [loc : Location]))
  #+end_src
- All other environment operations are the same
- Lookup now has type:
#+begin_src racket
(define (lookup [n : Symbol] [env : Env]) : Location ....)
#+end_src
*** Interpreting Variables
#+begin_src racket
(define (interp [env : Env]
                [e : Expr]
                [sto : Store]) : Result
  (type-case Expr e
    [(Var x)
     (v*s (fetch (lookup x env) sto) sto)]
....))
#+end_src
- Previously, we just looked up a value with ~lookup~
- Now we lookup a /location/
  + Have to use ~fetch~ to get its value from the store
- Produce that value, along with the unchanged store
*** Adding mutation: Curly-Mutvar
- Curly syntax: ~{setvar! SYMBOL <expr>}~
  + ~{setvar! x e}~ changes the value of in-scope variable ~x~ to be the value of ~e~
- Interpreting
  + Just like ~SetBox~ except we get the location from the environment, instead of by evaluating a box
  #+begin_src racket
  (define (interp [env : Env]
                [e : Expr]
                [sto : Store]) : Result
  (type-case Expr e
    [(Setvar! x e)
     (with ([e-val e-sto] (interp env e sto))
      (v*s e-val
        ;; Get the location from the environment
        (override-store (cell (lookup x env) e-val)
                        e-sto)))]
  ....))
  #+end_src
*** Function Calls
- To call a function, we evaluate the body in the environment extended with the argument value
  + Environment now takes /locations/
  + Need a location to associate with the new variable
  + Need to make sure the argument value ends up at that location
- If the argument is e.g. a number, then we have to make a new location for it
- /What if the argument is already a variable?/
  + Have a design decision
*** Pass-by-value
- If we implement function calls using pass-by-value, then:
  + *Each function call generates a new location where its argument values are stored*
  + If the arguments are variables, their values are looked up and copied to the new location
*** Pass-by-value interp
#+begin_src racket
[(Call funExpr argExpr)
     (with ([fun-v fun-sto] (interp env funExpr sto))
        (with ([arg-v arg-sto] (interp env argExpr fun-sto))
          (let* (
            [funPair (checkAndGetClosure fun-v)] ;; Function might be an expression, so have to evaluate
            [argVar (fst (fst funPair))]
            [funBody (snd (fst funPair))]
            [funEnv (snd funPair)]
            ;; Allocate a new location for the argument value
            [argLoc (new-location arg-sto)]
            ;; new store with the arg value at the new location
            ;; Use most recent store from arg
            [body-sto (override-store (cell argLoc arg-v) arg-sto)])
           ;; Evaluate the body in the extended *closure* env
           ;; with the new location bound to the parameter name,
           ;; using the new store with the argument value
          (interp (extendEnv (bind argVar argLoc) funEnv)
                  funBody
                  body-sto))))]
#+end_src
*** Pass-by-reference
- Pass-by-reference means that, when a function argument is a variable,
  the function's body is evaluated in an environment
  /where the argument variable is bound to the input variable's location/
- Changes to one will be seen in the other
*** Interpreting
#+begin_src racket
;; Everything the same as pass-by-value
;; except we check if the argument is a variable
;; and use its location instead of the new one if it us
(type-case Expr argExpr
  [(Var x)
     (interp (extendEnv (bind argVar (lookup x env)) funEnv)
                  funBody
                  arg-sto))))]
  ;; Otherwise do the same as call-by-value
  [else ....])
#+end_src
*** The Difference
- Any changes made to the parameter variable are lost in pass-by-value, but kept in pass-by-reference
- Pass by value means that a function can only mutate locations that it is /explicitly given/
  + i.e. as box parameters
- Pass by reference allows you to abstract over patterns of mutation
  + e.g. Write a function that says "change these variables in this way" that can be used over and over again
  + e.g. swap two variable's values
*** Example
#+begin_src racket
{letvar y 2
  {letvar f {fun {x} {begin
                     {setvar! x {* x 3}}
                     x}}
        {+ {f y} y}}}
#+end_src
- In both pass-by-value and pass-by-reference, the call to ~{f y}~ produces 6
- In pass-by-value, ~x~ has a different location than ~y~, that started off with ~2~ (the value of ~y~)
  + The final addition adds the value of ~{f y}~ to the value of ~y~, which did not change
  + ~{+ 6 2}~, result of 8
- In pass-by-reference, ~x~ refers to the same store location as ~y~
  + Setting the value of ~x~ changes ~y~ because they both refer to the same location
  + Result is 12, since both the call and ~y~ have the value of ~6~
*** Which to Choose?
- We will use pass-by-value, since it's simpler
  + C++ is pass by value, but sometimes that value is a pointer/reference
- However, we can replicate pass-by-reference using Boxes
  + This is what e.g. Python does
    - Most objects are implicitly boxed, so it seems like pass by reference
    - Actually passing a value, but the value is (something like) a box
    - Immutable types (like tuples) are passed by value
*** Aliasing
- To enable passing by reference, we add an /aliasing expression/ to Curly-Mutvar
  +  Like "address-of" operator ~&~ in C++
- ~{getloc SYMBOL}~ produces a box whose location is the same location as whatever in-scope symbol it is given
  + e.g. ~{getloc x}~ would produce ~{BoxV l}~ where ~l~ is the location in the environment for ~x~
- Interpreting:
  + Like new-box, except we look up the location in the environment instead of getting a new one
#+begin_src racket
    [(GetLoc x)
      (v*s (BoxV (lookup x env))
        ;; No changes to the store
        sto)]
#+end_src
- Now the box and the variable point to the /same location/
- Changes to one are seen in the other
*** Example
#+begin_src racket
{letvar doublebox! {fun {x} {set-box! x {* 2 {unbox x}}}}
        letvar y 3
        {begin {doublebox {getloc y}}
               y}}
#+end_src
- Function takes in a box, gets its value, doubles it, and writes it to the same location
- The ~getloc~ makes a new box whose location is the same as ~y~
- When ~doublebox!~ runs it alters the value at the location of its box, which was the location of ~y~
- The final result is 6, since the value of ~y~ was changed
* Implementing Recursion via State
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides019-recursion.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Recursion via State
*** Overview
- Goals
  + To see how to implement an interpreter for a language with recursion
  + To see how recursion interacts with environments and stores
- Key Concepts
  + Landin's Knot
*** Recursion in Curly-Rec
- When we are allowed to refer to ~x~ while defining the value that is assigned to ~x~
- We'll do this with a special ~let~ form
  + ~{letrec x <expr> <expr>}~
    - Gives ~{letrec x e1 e2}~ gives ~x~ the value ~e1~ then evaluates ~e2~ with ~x~ in scope
    - Exactly like ~letvar~, except *~x~ is also in scope in e1*
*** Bad Recursion
- We can't give ~x~ a value if we need to evaluate ~x~ to get that value
- E.g.
  + ~{letrec x {+ x 1} ....}~
  + Should raise an error or loop forever
  + In a later lecture we'll see a way to give this semantics
*** Good Recursion
- What can we define with recursion?
  + Definitions that refer to ~x~ but don't try to evaluate it
  + *Recursive occurrences of the variable must be in the body of a lambda*
    - Lambda bodies aren't evaluated until call time
*** Interpreting Recursion: The Problem
- To interpret ~{letrec x e1 e2}~ recursively
  + Need ~x~ in scope when interpreting ~e1~
  + Can't put ~e1~'s value because we haven't computed it yet
  + Can't compute ~e1~'s value because we need something for
*** Interpreting Recursion: Idea
- With Mutable Variables, the environment stores /locations/, not values
- For ~{letrec x e1 e2}~
  + Generate a new location for the recursive ~x~ being defined
    - Put a dummy value at it
  + Interpret ~e1~ in the environment extended with ~x~'s location
    - If ever fetch from that location, get the dummy value and raise an error
    - Shouldn't ever fetch if self-references are in the bodies of functions
  + Then, *update the store to contain the value of ~e1~ at the location of ~x~*
  + Then, interpret the body ~e2~ with this updated store
*** Interpreting Recursion: Code
#+begin_src racket
(define (interp [env : Env]
                [e : Expr]
                [sto : Store]) : Result
  (type-case Expr e
   [(LetRec x xexpr body)
     (let* ([x-loc (new-loc sto)] ;; Location for x
            [dummy-sto ;; Put a dummy value at x's location
               (override-store (cell x-loc
                                     (Var 'recursionError)))])
        (with ([x-val x-sto]
               ;; Interpret xexpr in env with x's location
                 (interp (extendEnv (bind x x-loc) env)
                          xexpr
                          dummy-sto))
         ;; Interpret body in env with x's location
         ;; and store with x's newly computed value
         ;; plus any side-effects from xexpr
         (interp (extendEnv (bind x x-loc) env) body
                 (override-store (cell x-loc x-val) x-sto))))]
#+end_src
*** Example
#+begin_src racket
{letrec fact {fun {x}
                  {if0 x
                       1
                       {* x {fact {- x 1}}}}}
        {fact 3}}
#+end_src
- To evaluate ~letrec~ we:
  + Make a new location ~0~ for ~fact~
  + Evaluate the value for ~fact~
    - Env: ~fact := 0~
    - Store: ~0 => (Var 'recursionError)~
      ~~
*** Example (ctd)
- Evaluating function produces closure:
#+begin_src racket
(ClosureV
   (Fun 'x (If0 (Var 'x)
                (NumLit 1)
                (Times (Var 'x)
                       (Call (Var 'fact)
                             (Plus (Var 'x)
                                   (Times (NumLit 1) (NumLit -1)))))))
   (fact := 0))
#+end_src
- Never fetch from location 0
  + Interp of function doesn't interp body of function
- Closure captures environment with ~fact := 0~
  + Only captures environment, *not store*
*** Example (ctd)
- Then tie the knot
  + Env: ~fact := 0~
  + Store: ~0 ==> (ClosureV (Fun 'x ....) (fact := 0))~
    - Updated with value for ~fact~
- Cyclic data structure:
  + Store contains closure at location 0
  + Closure stores environment ~(fact := 0)~
  + That environment points to 0 in store
  + Store contains closure at location 0 ....
*** Example (ct)
#+begin_src racket
{letrec fact {fun {x}
                  {if0 x
                       1
                       {* x {fact {- x 1}}}}}
        {fact 3}}
#+end_src
- Finally evaluate body in updated store
  + Env: ~fact := 0~
- ~3~ evaluates to ~(NumLit 3)~, ~fact~ evaluates to closure from location 0
- Call evaluates closure body
  + Environment ~x := 1, fact := 0~
  + Store ~0 ==> (ClosureV ....), 1 ==> (NumV 3)~
- ~If0~ in closure body goes to branch with call
- ~fact~ in call evaluates to /the same closure/ at location 0
  + Evaluation repeats, but with ~x~ bound to location with ~NumV 2~
  + Etc. until we reach 0 and don't have a recursive call
*** Landin's Knot
- This trick is general
  + Known as /Landin's Knot/
  + British Computer Scientist Peter Landin
  + Pioneer of functional programming
    - Invented the term /syntactic sugar/
    - Saw the connection between lambda calculus and programming
- You can simulate recursion in any language with
  + First-class functions/closures
  + Mutable references/variables
- Useful in typed languages that can't give the Y-combinator a type
* Local Variables :noexport:
Local Variables:
org-latex-packages-alist: nil
End:



