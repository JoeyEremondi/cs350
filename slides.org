#+subtitle: CS 350
#+AUTHOR: Prof. Joseph Eremondi


#+OPTIONS: toc:nil H:2 num:t
#+OPTIONS: TODO:nil

#+latex_header: \usepackage[sfdefault]{atkinson} %% Option 'sfdefault' if the base
#+latex_header: \usepackage[default]{FiraMono}
#+latex_header: \usepackage[T1]{fontenc}


#+EXPORT_FILE_NAME: slides_all.pdf
#+OPTIONS: toc:nil
#+startup: beamer
#+LaTeX_CLASS:beamer
#+LaTeX_CLASS_OPTIONS: [bigger]
#+LaTeX_CLASS_OPTIONS: [dvipsnames]
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)
#+beamer: \beamerdefaultoverlayspecification{<+->}

#+latex_header: \renewcommand{\pageword}{}


# #+latex_header: \usetheme[customfont,nofooter]{pureminimalistic}
#+latex_header: \usetheme{moloch}
# #+latex_header:\definecolor{textcolor}{RGB}{0, 0, 0}
#+latex_header:\definecolor{title}{RGB}{2, 71, 49}
#+latex_header:\renewcommand{\beamertextcolor}{textcolor}
# #+latex_header:\renewcommand{\beamerfootertextcolor}{footercolor}
# #+latex_header:\renewcommand{\beamertitlecolor}{title}
# #+latex_header:\setbeamertemplate{frametitle}{\\setbeamercolor{alerted text}{fg=black}
#+latex_header: \setbeamercolor{alerted text}{fg=black}
#+latex_header: \setbeamerfont{alerted text}{series=\bfseries}
#+latex_header: \newcommand{\colored}[2]{{\color{#1} #2}}

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides001-intro.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
** Course Overview
*** Course Objectives
To learn:
- Functional programming
  + Recursion
  + Immutable data
  + Programming by cases
  + Higher-order functions
- How to write your own programming language
  + Parsing/Abstract Syntax
  + Desugaring
  + Typechecking
  + Evaluation

- _To change how you /think/ about programming_
*** Textbook
- /Programming Languages: Application and Interpretation/, 2nd edition, by Shriram Krishnamurthi
  + aka PLAI
  + Freely avaliable online, pdf in UR Courses
- 3rd edition also available
  + Optional additional reference
  + Similar content but very different approach

*** Structure
- Grading scheme
  + 30% assignments
  + 20% midterm
    - In-class
  + 50% final
    - Aug 19
    - 2pm-5pm
    - This room
**** TODO Midterm date
*** Assignments
- Six weekly assignments
- Due Tuesday at 5pm
  + No extensions
  + Lowest grade dropped
- Submitted over UR Courses
*** Assignments (ctd.)
- Mostly programming
  + Some conceptual questions
- Score based on running tests
  + Some public (included in assignment)
  + Some private (only known by me)
  + Code doesn't run => no marks
- Some points for style/documentation/etc.
  +  Sample based marking
** Motivation: Functional Programming
*** Programming in This Class
- In plait
  + i.e., "PLAI-typed"
- Plait is
  + a programming language
  + a library for the Racket programming language
- We'll learn more why this distinction is fuzzy
*** What is Racket
- A programming language for writing programming languages
- LISP-like
  - parentheses
  - functions are values just like anything else
- Functional: once a variable has a value, it never changes
  + Racket does let you mutate variables,
    but those parts of the language are *forbidden* in this class

*** Will I Ever Use Racket in Industry?
**** \qquad
*****   \centering\huge _No_
*****   \centering (probably)
*** Future Proofing
- Don't know what you'll use in industry in 10 years
  + If you know how languages work, you can learn /any/ language quickly
  + Racket is effective for learning how languages work

*** Language Trends
**** \colored{RoyalBlue}{Objective C} vs \colored{BrickRed}{Swift}
[[./img/objc_vs_swift.png]]
**** \colored{RoyalBlue}{C++} vs \colored{BrickRed}{Python}
[[./img/cpp_vs_python.png]]
*** Syntax Vs Semantics
- Semantics
  + What a program /means/
  + How a program behaves
- Different syntaxes can have identical semantics
- _Course goal:_ Learning to see past syntax and understand a program
  as its semantics
- Racket looks very different from other languages
  + Expressions, not statements
  + Recursion, not loops
  + Parentheses & functions, not operators
- Changes how you think about programs

*** Seeing Past Syntax
 By the end of the course, you should be able to look at these programs and intuitively
 know that they're doing the same thing:

**** CPP
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+latex: {\scriptsize
  #+begin_src C
  int pow (int x, int y){
    int ret = 1;
    for (int i = 0; i < y; i++){
      ret *= x;
    }
    return ret;
  }
  #+end_src
#+latex: }

**** Racket
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+latex: {\scriptsize
  #+begin_src racket
  (define (pow x y)
    (if
      (<= y 0)
      0
      (* x (pow x (- y 1)))))
  #+end_src
#+latex: }



*** Functional Programming Going Mainstream?
- We're seeing more languages adopt functional features
- Anonymous functions (lambda)
  + Python, Ruby, JS, PHP, Swift, Go, Rust, etc.

  + Added to C++11

  + Added in Java 8
  + Most language have some form of ~map~ to apply a function to each element of a list

- Sum types
  + Also called variants, algebraic datatypes
  + Perfect for syntax trees
  + Now in Python, Typescript, C++ (~std::variant~), Java (sealed interfaces), Rust (enums)

- Learning these featuers in Racket will help if/when they show up in other languages in the future


** Motivation: Interpreters
    
*** Importance of Programming Languages
- Interpreter: Code + input => Output + effects (write to disk, display pixels, etc)
- You interact with a compiler or interpreter every time you:
  + Write a program
  + Run a program
    - Python, JavaScript, JVM all use some kind of interpreter
    - The CPU is just an interpreter for machine code

*** Programming Languages Aren't Magic
- Understanding how languages are implemented can help you understand your code
  + Why is it slow/fast
  + How to prevent/properly handle errors
  + How to know that it's doing what you think it does

*** Domain Specific Languages
- Small language for a particular kind of task

*** Is this a hard course?
**** Why interpreters are hard
- By the end if this course, you will be able to write a program that is
  powerful enough to simulate every other computer program that ever has or
  ever will be written

**** Why interpreters are easy
- It's just a bunch of tree traversals


* Racket and Plait
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides002-plait.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** Racket
*** What is Racket?
- Lisp-style language
  + ~((((((((Parentheses))))))))~
- Language for making languages

*** What is Dr. Racket?
- IDE for Racket
- Read-Eval-Print-Loop (REPL)
  + Feedback when writing code
- Other editors are possible
  + ... but you're on your own if you have probems
  + see https://docs.racket-lang.org/guide/other-editors.html

** Plait
*** What is Plait?
- Language defined in Racket
- Type inference
  + Every expression is typed
  + Don't have to write down the types
