#+subtitle: CS 350
#+AUTHOR: Dr. Joseph Eremondi
#+DATE: Last updated: \today{}



#+OPTIONS: toc:nil H:2 num:t TODO:nil eval:yes

#+BEAMER_HEADER: \usepackage[sfdefault]{atkinson} %% Option 'sfdefault' if the base
#+BEAMER_HEADER: \usepackage{FiraMono}
#+BEAMER_HEADER: \usepackage[T1]{fontenc}




#+EXPORT_FILE_NAME: slides_all.pdf
#+startup: beamer
#+LaTeX_CLASS:beamer
#+LaTeX_CLASS_OPTIONS: [bigger]
#+LaTeX_CLASS_OPTIONS: [dvipsnames]
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)
#+beamer: \beamerdefaultoverlayspecification{<+->}


# -*- org-latex-packages-alist: nil; -*-

# #+BEAMER_HEADER: \renewcommand{\pageword}{}


# #+BEAMER_HEADER: \usetheme[customfont,nofooter]{pureminimalistic}
#+BEAMER_HEADER: \usetheme{moloch}
# #+BEAMER_HEADER:\definecolor{textcolor}{RGB}{0, 0, 0}
#+BEAMER_HEADER:\definecolor{title}{RGB}{2, 71, 49}
# #+BEAMER_HEADER:\renewcommand{\beamertextcolor}{textcolor}
# #+BEAMER_HEADER:\renewcommand{\beamerfootertextcolor}{footercolor}
# #+BEAMER_HEADER:\renewcommand{\beamertitlecolor}{title}
# #+BEAMER_HEADER:\setbeamertemplate{frametitle}{\\setbeamercolor{alerted text}{fg=black}
#+BEAMER_HEADER: \setbeamercolor{alerted text}{fg=black}
#+BEAMER_HEADER: \setbeamerfont{alerted text}{series=\bfseries}
#+BEAMER_HEADER: \newcommand{\colored}[2]{{\color{#1} #2}}

#+BEAMER_HEADER: \usepackage{semantic}
#+BEAMER_HEADER: \usepackage{stmaryrd}
#+BEAMER_HEADER: \mathlig{=>}{\Rightarrow}
#+BEAMER_HEADER: \definecolor{LightGray}{gray}{0.9}
#+BEAMER_HEADER: \usepackage[outputdir=pdf]{minted}
#+BEAMER_HEADER: \usepackage{etoolbox}
#+BEAMER_HEADER: \usepackage{etoolbox}
#+BEAMER_HEADER: \AtBeginEnvironment{minted}{\pause} \setminted[racket]{escapeinside=||,bgcolor=LightGray,beameroverlays=true,baselinestretch=1.2,fontsize=\scriptsize}

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides001-intro.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil

** Course Overview
*** Course Objectives
To learn:
- Functional programming
  + Recursion
  + Immutable data
  + Programming by cases
  + Higher-order functions
- How to write your own programming language
  + Parsing/Abstract Syntax
  + Desugaring
  + Evaluation

- _To change how you /think/ about programming_
*** Textbook
- /Programming Languages: Application and Interpretation/, 2nd edition, by Shriram Krishnamurthi
  + aka PLAI
  + Freely avaliable online, pdf in UR Courses
- 3rd edition also available
  + Optional additional reference
  + Similar content but very different approach
  + When in doubt, we're following the 2nd edition

*** Course Communication
- Everything on URCourses
  + Announcements
  + Assignments and Handin
  + Textbook, Slides, Videos
  + Email
  + Discussion Forum

- Do NOT ask programming/conceptual questions by email
  + Use the discussion forum
  + If you're wondering, others are too
  + EXCEPTION: when you can't ask your question without revealing
    your solution to the assignment

*** Grading Scheme
  + 25% assignments
  + 25% midterm
    - In-class
    - Thursday, July 25
  + 50% final
    - Aug 19
    - 2pm-5pm
    - This room
*** Assignments
- Six weekly assignments
- Due Tuesday at noon (11:59am)
  + No extensions
  + Lowest grade dropped
- Submitted over UR Courses
*** Assignments (ctd.)
- Mostly programming
  + Some conceptual questions
- Score based on running tests
  + Some public (included in assignment)
  + Some private (only known by me)
  + Code doesn't run $->$ no marks
- Some points for style/documentation/etc.
  +  Sample based marking
*** Attendance
- Attendance is mandatory but unenforced
  + Lecture contents is fair game for exams
- Lectures will contain walk-throughs of code
  and problem solving examples
- This is NOT a memorization-focused class
- I'll do my best to post slides and example code from lectures
  + But ultimately it's your responsibility to catch up on missed material
*** Office Hours :
- Mon 2:30-3:45pm
- Mon 4:30-5:15pm
- Wed 11:00am-11:45am
- Thurs 2:30-3:45pm
- RIC 317
  + Take the elevator to 3rd floor, then go straight across
*** LLM Policy
**** Use of ChatGPT, GitHub Copilot, or any other Large Language Model or Generative AI is forbidden when completing the assignments for this class
- Considered a violation of Academic Integrity
**** ChatGPT has trouble with Racket/plait
- Don't expect sympathy if you copy/paste code from an LLM that doesn't work
**** Don't set yourself up for failure on the exams
- Doing the assignments is the best way to study
** Motivation: Functional Programming
*** Programming in This Class
- In plait
  + i.e., "PLAI-typed"
- Plait is
  + a programming language
  + a library for the Racket programming language
- We'll learn more why this distinction is fuzzy
*** What is Racket
- A programming language for writing programming languages
- LISP-like
  - parentheses ~(((((((((())))))))))~
  - functions are values just like anything else
- Immutable: once a variable has a value, it never changes
  + Racket does let you mutate variables,
    but those parts of the language are *forbidden* in this class
    - Unless otherwise specified

*** Will I Ever Use Racket in Industry?
**** \qquad
*****   \centering\huge _No_
*****   \centering (probably)
*** Future Proofing
- Don't know what you'll use in industry in 10 years
  + If you know how languages work, you can learn /any/ language quickly
  + Racket is effective for learning how languages work

*** Language Trends (from Google Trends)

**** \colored{RoyalBlue}{Objective C} vs \colored{BrickRed}{Swift}
[[./img/objc_vs_swift.png]]

**** \colored{RoyalBlue}{C++} vs \colored{BrickRed}{Python}
[[./img/cpp_vs_python.png]]
*** Syntax Vs Semantics
- Semantics
  + What a program /means/
  + How a program behaves
- Different syntaxes can have identical semantics
- _Course goal:_ Learning to see past syntax and understand a program
  as its semantics
- Racket looks very different from other languages
  + Expressions, not statements
  + Recursion, not loops
  + Parentheses & functions, not operators
- Changes how you think about programs

*** Seeing Past Syntax
 By the end of the course, you should be able to look at these programs and intuitively
 know that they're doing the same thing:

**** CPP
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+latex: {\scriptsize
  #+begin_src C :exports code
  int pow (int x, int y){
    int ret = 1;
    for (int i = 0; i < y; i++){
      ret *= x;
    }
    return ret;
  }
  #+end_src
#+latex: }

**** Racket
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+latex: {\scriptsize
#+begin_src racket :exports code
(define (pow x y)
  (if
    (<= y 0)
    0
    (* x (pow x (- y 1)))))
#+end_src
#+latex: }



*** Functional Programming Going Mainstream?
- We're seeing more languages adopt functional features
- Anonymous functions/closures (lambda)
  + Python, Ruby, JS, PHP, Swift, Go, Rust, etc.

  + Added to C++11

  + Added in Java 8
  + Most language have some form of ~map~ to apply a function to each element of a list

- Sum types
  + Also called variants, algebraic datatypes
  + Perfect for syntax trees
  + Now in Python, Typescript, C++ (~std::variant~), Java (sealed interfaces), Rust (enums)

- Learning these features in Racket will help if/when they show up in other languages in the future


** Motivation: Interpreters
    
*** Importance of Programming Languages
- Interpreter: (Code , input) $\hookrightarrow$ (Output , effects)
  + Effects: write to disk, display pixels, etc
- You interact with a compiler or interpreter every time you:
  + Write a program
  + Run a program
    - Python, JavaScript, JVM all use some kind of interpreter
    - The CPU is just an interpreter for machine code

*** Programming Languages Aren't Magic
- Understanding how languages are implemented can help you understand your code
  + Why is it slow/fast
  + How to prevent/properly handle errors
  + How to know that it's doing what you think it does

*** Domain Specific Languages :noexport:
- Small language for a particular kind of task

*** Is this a hard course?
**** Why interpreters are hard
- By the end if this course, you will be able to write a program that is
  powerful enough to simulate every other computer program that ever has or
  ever will be written

**** Why interpreters are easy
- It's just a bunch of tree traversals


*** Intro

**** Questions?
* Functional Programming 1: Recursion and Immutable Data
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides002-plait.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

*** Overview
- Topic: Functional Programming in Racket and plait
- Required Reading:
  + Plait tutorial (URCourses)
- Optional Reference
  + Plait videos, HtDP videos
** Programming in CS 350
*** All coding for this class uses:
- The Racket Programming Language
- The ~plait~ library for Racket
- The Dr. Racket editor
** Racket
*** What is Racket?
- Lisp-style language
  + ~((((((((Parentheses))))))))~
- Language for making languages

*** What is Dr. Racket?
- IDE for Racket
  - Syntax highlighting
  - Other useful features
- Read-Eval-Print-Loop (REPL)
  + Feedback when writing code
  + Can  evaluate expressions while you're writing your code
- Other editors are possible
  + ... but you're on your own if you have problems
  + see https://docs.racket-lang.org/guide/other-editors.html

** Plait
*** What is Plait?
****  "PLAI-typed"
**** Language defined in Racket
- Racket functions you can call
- Adds syntax to Racket
  + Declaring and pattern matching on data types
  + Type annotations for functions
- Minimal
  + Has what you need to write programming languages
  + Not much else
  + You can do a lot with very little

*** Plait features:

- Type inference
  + Every expression is typed
  + Don't have to write down the types
- Algebraic Data Types



*** Parentheses
- Racket programs are trees called "S-expressions"
- Parentheses give this tree structure
- Default: parentheses mean function call
  + Racket writes ~(f x)~, not ~f(x)~
- ~x~ is not the same as ~(x)~
  + ~x~ gets the value of the variable ~x~
  + ~(x)~ is calling a function named ~x~ with zero arguments

*** Numbers

****   
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:

#+name: plait-numbers
#+begin_src racket :exports both
;;!!appear!!
;;!!results!!
(+ 2 7)
(- 10 0.5)
(* 1/3 2/3)
(/ 1 1000000000000.0)
(max 10 20)
(modulo 10 3)
#+end_src

****    
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:
#+BEGIN_EXPORT latex
\onslide<1->
#+END_EXPORT
#+RESULTS: plait-numbers


*** Booleans

****   
:PROPERTIES:
:BEAMER_COL: 0.68
:BEAMER_ENV: block
:END:

#+name: plait-booleans
#+begin_src racket :exports both
;;!!appear!!
;;!!results!!
(= (+ 2 3) 5)
(> (/ 0 1) 1)
(zero? (- (+ 1 2) (+ 3 0)))
(and (< 1 2) (> 1 0))
(or (zero? 1) (even? 3))
#+end_src

****    
:PROPERTIES:
:BEAMER_COL: 0.28
:BEAMER_ENV: block
:END:
#+BEGIN_EXPORT latex
\onslide<1->
#+END_EXPORT
#+RESULTS: plait-booleans


        
***  Conditionals
- Conditionals are *expressions*, not statements
- Boolean changes what the expression *is*, not what it does
#+begin_src racket :exports both
(if (< 2 3) "hello" "goodbye")
(+ 3
  (if (= 2 (+ 1 1))
      3
      40))
#+end_src

***  Functions
- Calling a function replaces variable with concrete argument
#+begin_src racket :exports both
(define (addOne [x : Number]) : Number
  (+ x 1))
(addOne 10)
#+end_src

***  Functions
#+begin_src racket :exports both
(define (isRemainder [x : Number]
                     [y : Number]
                     [remainder : Number])
        : Boolean
  (= remainder (modulo x y)))
(isRemainder 10 3 1)
(isRemainder 10 4 1)
#+end_src

***  Functions (ctd.)
- General form:

#+begin_src racket :exports code
(define (functionName
         [argName : argType]
         ...
         [argNameN : argTypeN]) : returnType
  functionBody)
#+end_src
- Later in the course we'll see another way of defining functions

*** Symbols
- Special type in Racket
- Written with single quote ~'a~, ~'hello~, ~'foo~
- Like strings, but you don't ever traverse/concatenate/look inside
- Only relevant operation is comparison
  + ~(symbol=? 'a 'b)~
  + Compares pointers, so very fast




*** Intermediate definitions
- Can still define variables
  + Once they're given a value, never changes
  + Allows re-use
    - Only evaluated once, can use multiple times
#+begin_src  racket :noweb strip-export :exports both
(define (squaredSum [x : Number]
                    [y : Number]) : Number
  (let ([xy (+ x y)])
    (* xy xy)))
(squaredSum 1 2)
#+end_src

#+RESULTS:
#+begin_src racket
9
#+end_src

*** Alternate Versions of Let
- ~let*~ : multiple definitions, later ones can refer to earlier ones
- 99% of the time this is what you want to use
  #+begin_src racket
    (let* ([x (+ 2 3)]
           [y (* x x)])
      (* y y))
  #+end_src


- ~letrec~ : multiple definitions that can all refer to each other
  + We'll see this later when we learn about lambdas
** Functional Thinking and Recursion

*** What Is Functional Programming?
- Functions in our program correspond to functions in math
  + Mapping from inputs to outputs
  + Same inputs always produce the same outputs
- Talk about what programs *are*, not what programs do
- Instead of changing variable values
  + We call functions with different arguments
- Instead of changing data structures
  + We decompose them, copy the parts, and reassemble them in new ways
  + Copying is implemented with pointers
    - Fast, memory efficient

*** Advantages of Functional Programming
- All program state is *explicit*
  + Easy to tell exactly what a function can change
  + No shared state between components
    - Other function can't change value without realizing
    - No data races for threading
- Programming is *declarative*
  + Structure of the problem guides structure of the solution
- Equational reasoning
  + In imperative languages, equals sign ~=~ is a LIE
    - Can write ~x = 3; x = 4;~, but ~3 != 4~
  + If have ~(define (f x) body)~, then for all ~y~,
    ~(f y)~ and ~body~ are interchangable
    - after replace ~x~ with ~y~ in ~body~
    - Easier to tell if your program is correct
    - Some optimizations easier
*** Disadvantages of Functional Programming
- None?
- Sometimes slower
  + Very hard to do without Garbage Collection
    - e.g. see Closures in Rust
  + Sometimes faster because you need fewer safety checks in your code
- Farther from what the CPU is actually doing
- Some algorithms are more concise with mutation
  + But lots aren't
*** How to design functional programs
**** 5 Step method:
1. Determine the *representation* of inputs and outputs
2. Write *examples* and tests
3. Create a *template* of the function
   - Depends on input/output types
   - Covers all cases
   - Possibly extracts fields, recursive calls, etc.
4. *Fill* in the holes in the template

5. *Run* tests

**** Further reference:
http://htdp.org, Matthew Flatt's Notes (URCourses)




*** Factorial - Representation
- $n! = 1 \times 2 \times \ldots n$
- Takes in a (natural) number, outputs a number
  #+begin_src racket
  (define (factorial [n : Number]) : Number
    (error 'factorial "TODO"))
  #+end_src


*** Factorial - Examples
  #+begin_src racket
   ;;!!appear!!

  (test (factorial 0) 1 )
  (test (factorial 1) 1 )
  (test (factorial 2) 2 )
  (test (factorial 3) 6 )
  (test (factorial 4) 24 )
  (test (factorial 5) 120 )
  #+end_src
- Notice the pattern?

*** Factorial - Template
- A natural number is either
  + Zero
  + One more than some other number
    - We call this the "successor", written "S" or "suc"
    - Probably want to use this in the solution
#+begin_src racket
(define (factorial [n : Number]) : Number
  (if (zero? n)
      (error 'zero "TODO")
      (let ([n-1 (- n 1)])
        (error 'suc "TODO"))
      ))
#+end_src


*** Factorial - Recursion
- Divide problem into base case and recursive cases
- Can use recursive calls to smaller arguments
- Build up solution in terms of solutions to smaller problems
#+begin_src racket
(define (factorial [n : Number]) : Number
  (if (zero? n)
      (error 'zero "TODO")
      (let*
          ([n-1 (- n 1)]
           [fn-1 (factorial n-1)])
          (error 'suc "TODO"))
      ))
#+end_src

*** Factorial - Filling holes
- Example gives the base case for 0
- Notice the pattern
  + Multiplying the first n numbers is the same as n times the first n-1 numbers
  + We get that from our recursive call
#+name: factorial-complete
#+begin_src racket
(define (factorial [n : Number]) : Number
  (if (zero? n)
      1
      (let*
          ([n-1 (- n 1)]
           [fn-1 (factorial n-1)])
          (* n fn-1))
      ))
#+end_src


*** Run Tests
#+begin_src racket :exports both :noweb strip-export
<<factorial-complete>>
(test (factorial 0) 1 )
(test (factorial 5) 120 )
#+end_src


*** Trust the Natural Recursion

- The magic key:
  + /Assume/ you have a solution already, but only for smaller arguments
  + Express solution for larger ones in terms of smaller ones
  + Like induction in math
- The shape of the data guided the shape of the solution
  + Zero had no sub-data, so there were no recursive calls
  + $suc\ n$ has one sub-value, namely $n$
    - One recursive call

*** Preconditions
- Note: types not quite precise enough
  + e.g. ~(factorial -1)~ or ~(factorial 1/2)~ loop forever
- Precondition: argument is a non-negative whole number
  + Can't express this in the code, so write in the comments
  + Aside: I research languages where you /can/ express this with types

*** Another Example: Exponentiation
+ Live coding in Dr. Racket



** Unbounded Data: Lists

*** Functional Linked Lists
- Every linked list is one of:
  + Empty (sometimes called ~nil~ or ~null~)
  + An element appended to the beginning of another list
- We call the operation of appending an element to a list ~cons~
  + Historical name, goes back to LISP days
- Cons does *not* change its input
  + Creates a new list whose tail is the old list

*** Lists in Racket
+ Multiple ways to write lists
+ ~'()~ is the empty list, can also write ~empty~
+ Extending lists:  ~(cons h t)~ creates list with element ~h~ appended to list ~t~
  - ~h~ and ~t~ for ~head~ and ~tail~
+ List literals, can write ~(list 1 2 3 4)~ or ~'(1 2 3 4)~
  - Shorthand for:
  - ~(cons 1 (cons 2 (cons 3 (cons 4 '()))))~
+ Lots more helper functions, see the documentation


*** Template for Lists
- Two cases: list is empty or cons
- Make a recursive call on tail of cons case
  #+begin_src racket
  (define (list-template
           [xs : (Listof Number)])
    (if (empty? xs)
        (error 'nil "TODO")
        (let ([h (first xs)]
              [t (rest xs)]
              [tRet (list-template t)])
          (error 'cons "TODO"))
        ))
  #+end_src

*** Example: Sum
#+begin_src racket :exports both
  (define (sum [xs : (Listof Number)])
    : Number
    (if (empty? xs)
        0
        (let* ([h (first xs)]
               [t (rest xs)]
               [tRet (sum t)])
          (+ h tRet))))
   (sum '())
   (sum '(1 2 3))
#+end_src

#+RESULTS:
#+begin_src racket
0
6
#+end_src

*** Pattern Matching: Motivation
+ Recursive case: used "getter" function to get the sub-data in the recursive case
  - ~(- x 1)~ for numbers
  - ~first~ and ~rest~ for lists
+ Always want to have the sub-parts available
+ Don't want to apply getters on the wrong data
  - e.g. ~first '()~ will raise an error


*** Pattern Matching:


*** Example: Generating a Modified List
+ e.g. Increment each number in a list
  + Uses pattern matching
  + Shows how to create lists recursively
  #+begin_src racket :exports both
(define (increment [xs : (Listof Number)])
        : (Listof Number)
  (type-case (Listof Number) xs
    [empty
       empty]
    [(cons h t)
       (cons (+ h 1) (increment t))]))
(increment '(2 3 4))
  #+end_src



*** Parametric Polymorphism
+ Lists are a *parameterized type*
  - Only need to define once for the different element types
+ Many list functions are *polymorphic*
  - Work regardless of what type of elements there are
  - Types contain *type variables*, denoted with single quote ~'x~
    + Like symbols
  - Plait type inference figures out solutions for type variables when you call a function
  - E.g. ~first : ((Listof 'a) -> 'a)~
    + Input is list whose elements are some type ~'a~
    + Output has type ~'a~
    + e.g. ~first '(1 2 3)~ is a ~Number~, but ~first '(#t #f #t)~ is a Boolean
+ Later, this will be very useful for writing generic list operations

*** Example: List Concatenation
- We can combine two lists into a single list
- Polymorphic type
  + Works for list with any contents
  + We never do anything with the contents other than copy
  + This function is built into Plait as ~append~
    #+name: plait-concat-def
    #+begin_src racket :exports both
  (define (concat [xs : (Listof 'elem)]
                  [ys : (Listof 'elem)])
          : (Listof 'elem)
    (type-case (Listof 'elem) xs
      [empty
         ys]
      [(cons h t)
         (cons h (concat t ys))]))
    #+end_src

*** Example: List Concatenation (ctd.)
**** Example
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:
    #+name: plait-concat
    #+begin_src racket :exports both :noweb strip-export
  <<plait-concat-def>>
  ;;!!appear!!
  ;;!!results!!

  (concat '(1 2 3) '(4 5 6))
  (concat '("3" "5") '("0"))
  (concat '() '(#t))
  (concat '(#f) '())
    #+end_src

**** Results
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:
#+RESULTS: plait-concat


*** More Examples
- Demo: Dr. Racket (as time permits)
  + Duplicating each element of a list
  + "zipping" two lists together
  + Filtering out odd elements of a list


* Functional Programming 2: Defining Data Types
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides003-datatypes.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** Warmup: Pairs

*** Pairs: "AND" for types
-  ~(Number * Boolean)~
  + Cartesian product
    - "AND" for types
  + A value of this type contains a ~Number~ AND ~a Boolean~
  + Why is it infix? Who knows
    - Maybe to help distinguish it from multiplication
- Projections
  + Get the data from the pairs
#+begin_src racket :exports both
(define myPair : (Number * Boolean)
   (pair 2 #t))
(fst myPair) ;;Number
(snd myPair) ;;Boolean
#+end_src

#+RESULTS:
#+begin_src racket
2
#t
#+end_src
*** Pairs in General
- For any types ~'a~ and ~'b~ there is a type ~('a * 'b)~
- Build with ~pair : ('a 'b -> ('a * 'b))~
  + Takes one argument of each type, produces the pair
- Projections
  + ~fst : (('a * 'b) -> 'a)~
  + ~snd : (('a * 'b) -> 'b)~

** Algebraic Data Types

*** "OR" for types
- Pairs gave us "AND"
- What does "OR" look like for types?
  + ~(OR Number Boolean)~ should be the type of values that are either a number or a boolean
  + Want a tag so we can check which one it is
    - Called a "constructor"
    - not the same as Java/OOP constructor
- Saw some examples like this already
  + A number is zero OR one plus another number
  + A list is empty OR an element cons-ed to another list
- Racket lets us define our own types mixing AND and OR

*** First example

#+name: shape-defn
#+begin_src racket
(define-type Shape
  (Rectangle [length : Number]
             [width : Number])
  (Circle [radius : Number]))

(define tv (Rectangle 16 9))
(define loonie (Circle 1))
#+end_src
- ~Shape~ is a /datatype/
- It has two /constructors/, ~Rectangle~ and ~Circle~
  + i.e. a Shape is a circle or a rectangle
- ~Rectangle~ has two fields with type Number, ~length~ and ~width~
- ~Circle~ has one field with type Number

*** Creating values of a datatype
#+begin_src racket
(define-type Shape
  (Rectangle [length : Number]
             [width : Number])
  (Circle [radius : Number]))

(define tv (Rectangle 16 9))
(define loonie (Circle 1))
#+end_src
- We construct a Shape by calling a constructor
  + Doesn't *do* anything except package the data together
- A Shape either has two numbers OR one number
  + Depending on the tag
*** Auto-generated Functions
#+begin_src racket :noweb strip-export
<<shape-defn>>
(Rectangle? tv)
(Circle? tv)
(Rectangle-length tv)
;; (test/exn (Circle-radius tv) "")
  ;;raises an error, no such field present
#+end_src

#+RESULTS:
#+begin_src racket
#t
#f
16
#+end_src

*** Pattern matching
- Don't want to accidentally get a field that doesn't exist
- Almost always want to use the fields in the solution
- Solution: pattern-matching
#+begin_src racket :noweb strip-export :exports both
<<shape-defn>>
(define (area [shp : Shape]) : Number
  (type-case Shape shp
     [(Rectangle l w)
       (* l w)]
     [(Circle r)
       (* 3.14 (* r r))])
)
(area tv)
(area loonie)
#+end_src

#+RESULTS:
#+begin_src racket
144
3.14
#+end_src

*** Total Matching
- Missing a case in pattern matching is a /syntax error/
- Lets us know we are safe
- Can add an else clause to handle multiple cases
  + See Racket window
*** E.g. Representing Failure
+ In plait standard library
#+begin_src racket
(define-type (Optionof 'a)
  (none)
  (some [v : 'a]))
#+end_src
+ Pattern matching guarantees no null pointer errors
  - We'll see a more detailed example

*** Most Generic Form
#+begin_src racket
(define-type (Either 'a 'b)
  (Left [inLeft : 'a])
  (Right [inRight : 'b])
)
#+end_src
- You can define all (non-recursive) datatypes  with this and pairs
- e.g. Shape is ~(Either (Number * Number) Number)~

** Recursive Data

*** Self-reference in types
- The real power of datatypes is the ability to have fields of the type being defined
- This allows us to define *trees*
  + of arbitrary depth
- Data can be traversed using recursion


*** Example: Lists as a dataype
#+name: num-list
#+begin_src racket
(define-type NumList
  (Nil)
  (Cons [head : Number] [tail : NumList]))
#+end_src
- Note: this is not quite how lists are defined in Racket/plait
  + But they could be!
- Recursive fields in datatype $\to$ recursive calls in template
#+begin_src racket :noweb strip-export
<<num-list>>
(define (sum [xs : NumList])
  (type-case NumList xs
             [(Nil)
              0]
             [(Cons h t)
              (let ([sumRest (sum t)])
                    (+ h (sum t)))
              ]))
(sum (Cons 100 (Cons 20 (Cons 3 (Nil)))))
#+end_src

#+RESULTS:
#+begin_src racket
123
#+end_src

*** Example: Filesystem
+ Model of a file system
  - Not how is implemented on disk
#+name: fs-defn
#+begin_src racket
(define-type Filesystem
  (File [name : String]
        [data : Number])
  (Folder [name : String]
          [contents : (Listof Filesystem)]))
#+end_src

*** Linear Search using Recursion

- Find the first matching file
#+name: fs-search
#+begin_src racket :noweb strip-export

(define (search [target : String]
                [fs : Filesystem]) : (Optionof Number)
  (type-case Filesystem fs
             [(File name data)
              (if (string=? name target)
                  (some data)
                  (none))]
             [(Folder _ contents)
               (searchList target contents)]))
#+end_src

*** Helper Function: Searching the list
- We have mutually recursive types
  + ~Filesystem~ contains ~(Listof Filesystem)~
  + ~(Listof Filesystem)~ contains ~Filesystem~
- So we use mutually-recursive functions

#+name: fs-searchlist
#+begin_src racket

(define (searchList [target : String]
                    [files : (Listof Filesystem)])
        : (Optionof Number)
  (type-case (Listof Filesystem) files
             [empty (none)]
             [(cons h t)
              (let ([result (search target h)])
                (if (none? result)
                    (searchList target t)
                    result))
              ]))
#+end_src
*** Testing the search
#+begin_src racket :noweb strip-export :exports both
<<fs-defn>>
<<fs-search>>
<<fs-searchlist>>
(define InnerSolarSystem
  (Folder "Sun"
          (list (File "Mercury" 1)
                (File "Venus" 2)
                (Folder "EarthSystem"
                        (list (File "Earth" 3)
                              (File "Moon" 3.5)))
                (Folder "MarsSystem"
                        (list (File "Mars" 4)
                              (File "Phobos" 4.3)
                              (File "Diemos" 4.6))))))
(search "Moon" InnerSolarSystem)
(search "Jupiter" InnerSolarSystem)
#+end_src

#+RESULTS:
#+begin_src racket
(some 3.5)
(none)
#+end_src


* Intro to Interpreters
** TODO FOO
*** TITLE


*** TITLE
- An *interpreter *takes a program and returns it value
- *Plait *= the language that we use to write interpreters
- *Curly *= the language that to be interpreted
- ... that keeps changing


*** Curly Arithmetic
#+begin_src racket
(+ 2 1)
#+end_src racket
#+begin_src racket
#,step-arrow
#+end_src racket
#+begin_src racket
(* 2 1)
#+end_src racket
#+begin_src racket
#,step-arrow
#+end_src racket
#+begin_src racket
(+ 2 (* 4 3))
#+end_src racket
#+begin_src racket
#,step-arrow
#+end_src racket
#+begin_src racket

#+end_src racket
#+begin_src racket
#,step-arrow
#+end_src racket


*** Representing Expressions
#+begin_src racket

#+end_src racket
#+begin_src racket
(define-type
Exp
(numE (n : Number))
(plusE (l : Exp) (r : Exp))
(multE (l : Exp) (r : Exp)))
#+end_src racket


*** TITLE


*** Curly Interpeter
#+begin_src racket
(define (interp (a : Exp))
        :
        Number
        (type-case
        Exp
        a
        ((numE n) n)
        ((plusE l r) (+ (interp l) (interp r)))
        ((multE l r) (* (interp l) (interp r)))))
#+end_src racket


*** TITLE


*** Concrete vs. Abstract Syntax
#+begin_src racket
(+ 2 1)
#+end_src racket
#+begin_src racket
(plusE (numE 2) (numE 1))
#+end_src racket


*** Concrete Syntax as an S-Expression
#+begin_src racket
`(+ 2 1)
#+end_src racket
#+begin_src racket
(test (parse `(+ 2 1)) (plusE (numE 2) (numE 1)))
#+end_src racket


*** Concrete Syntax as an S-Expression
#+begin_src racket
(code:comment "An EXP is either")
#+end_src racket
#+begin_src racket
parse
#+end_src racket
#+begin_src racket
(define-type
Exp
(numE (n : Number))
(plusE (l : Exp) (r : Exp))
(multE (l : Exp) (r : Exp)))
#+end_src racket


*** Concrete Syntax as an S-Expression
#+begin_src racket
(code:comment "An EXP is either")
#+end_src racket
#+begin_src racket
parse
#+end_src racket
#+begin_src racket
(define-type
Exp
(numE (n : Number))
(plusE (l : Exp) (r : Exp))
(multE (l : Exp) (r : Exp)))
#+end_src racket


*** Concrete Syntax as an S-Expression
#+begin_src racket
(code:comment "An EXP is either")
#+end_src racket
#+begin_src racket
parse
#+end_src racket
#+begin_src racket
(define-type
Exp
(numE (n : Number))
(plusE (l : Exp) (r : Exp))
(multE (l : Exp) (r : Exp)))
#+end_src racket


*** Matching an S-Expression
#+begin_src racket
(code:comment "An EXP is either ...")
#+end_src racket
#+begin_src racket
(and (s-exp-list? s)
        (= 3 (length (s-exp->list s)))
        (s-exp-symbol? (first (s-exp->list s)))
        (eq? '* (s-exp->symbol (first (s-exp->list s)))))
#+end_src racket
#+begin_src racket
(s-exp-match? `(* ANY ANY) s)
#+end_src racket
#+begin_src racket
code:blank
#+end_src racket
#+begin_src racket
(define (parse (s : S-Exp))
        :
        Exp
        ....
        #,(lt-superimpose (ghost big-body) body)
        ....)
#+end_src racket
#+begin_src racket
(define (parse (s : S-Exp))
        :
        Exp
        ....
        #,(lt-superimpose (ghost big-body) body)
        ....)
#+end_src racket
#+begin_src racket
(cond
....
(#,g
        ....
        (parse (second (s-exp->list s)))
        ....
        (parse (third (s-exp->list s)))
        ....)
....)
#+end_src racket
#+begin_src racket
(define (parse (s : S-Exp))
        :
        Exp
        ....
        #,(lt-superimpose (ghost big-body) body)
        ....)
#+end_src racket
#+begin_src racket
(cond
....
(#,g
        ....
        (parse (second (s-exp->list s)))
        ....
        (parse (third (s-exp->list s)))
        ....)
....)
#+end_src racket
#+begin_src racket
(define (parse (s : S-Exp))
        :
        Exp
        ....
        #,(lt-superimpose (ghost big-body) body)
        ....)
#+end_src racket


* Local Variables :noexport:
Local Variables:
org-latex-packages-alist: nil
End:



# *** What's Algebraic about Algebraic Data Types? :noexport:

**** Boolean logic

- OR acts like + (sum)
- AND acts like * (product)

**** Sum Types
- ~(OR A B)~ is either an ~A~ or a ~B~
**** Algebraic Data Types
- Sums of Products
- Is the first constructor type OR the second constructor type OR ...
- Each constructor has a value of its first field type AND the second field type AND
- Algbraic laws for how they interact
  + We'll see more later
