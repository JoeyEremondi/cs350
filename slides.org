#+subtitle: CS 350
#+AUTHOR: Dr. Joseph Eremondi
#+DATE: Last updated: \today{}



#+OPTIONS: toc:nil H:2 num:t TODO:nil eval:yes

#+BEAMER_HEADER: \usepackage[sfdefault]{atkinson} %% Option 'sfdefault' if the base
#+BEAMER_HEADER: \usepackage{FiraMono}
#+BEAMER_HEADER: \usepackage[T1]{fontenc}




#+EXPORT_FILE_NAME: slides_all.pdf
#+startup: beamer
#+LaTeX_CLASS:beamer
#+LaTeX_CLASS_OPTIONS: [bigger]
#+LaTeX_CLASS_OPTIONS: [dvipsnames]
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)
#+beamer: \beamerdefaultoverlayspecification{<+->}


# -*- org-latex-packages-alist: nil; -*-

# #+BEAMER_HEADER: \renewcommand{\pageword}{}


# #+BEAMER_HEADER: \usetheme[customfont,nofooter]{pureminimalistic}
#+BEAMER_HEADER: \usetheme{moloch}
# #+BEAMER_HEADER:\definecolor{textcolor}{RGB}{0, 0, 0}
#+BEAMER_HEADER:\definecolor{title}{RGB}{2, 71, 49}
# #+BEAMER_HEADER:\renewcommand{\beamertextcolor}{textcolor}
# #+BEAMER_HEADER:\renewcommand{\beamerfootertextcolor}{footercolor}
# #+BEAMER_HEADER:\renewcommand{\beamertitlecolor}{title}
# #+BEAMER_HEADER:\setbeamertemplate{frametitle}{\\setbeamercolor{alerted text}{fg=black}
#+BEAMER_HEADER: \setbeamercolor{alerted text}{fg=black}
#+BEAMER_HEADER: \setbeamerfont{alerted text}{series=\bfseries}
#+BEAMER_HEADER: \newcommand{\colored}[2]{{\color{#1} #2}}

#+BEAMER_HEADER: \usepackage{semantic}
#+BEAMER_HEADER: \usepackage{stmaryrd}
#+BEAMER_HEADER: \mathlig{=>}{\Rightarrow}
#+BEAMER_HEADER: \definecolor{LightGray}{gray}{0.9}
#+BEAMER_HEADER: \usepackage[outputdir=pdf]{minted}
#+BEAMER_HEADER: \usepackage{etoolbox}
#+BEAMER_HEADER: \usepackage{hyphenat}
#+BEAMER_HEADER: \AtBeginEnvironment{minted}{\pause} \setminted[racket]{escapeinside=||,bgcolor=LightGray,beameroverlays=true,baselinestretch=1.2,fontsize=\scriptsize}

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides001-intro.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil

** Course Overview
*** Course Objectives
To learn:
- Functional programming
  + Recursion
  + Immutable data
  + Programming by cases
  + Higher-order functions
- How to write your own programming language
  + Parsing/Abstract Syntax
  + Desugaring
  + Evaluation

- _To change how you /think/ about programming_
*** Textbook
- /Programming Languages: Application and Interpretation/, 2nd edition, by Shriram Krishnamurthi
  + aka PLAI
  + Freely avaliable online, pdf in UR Courses
- 3rd edition also available
  + Optional additional reference
  + Similar content but very different approach
  + When in doubt, we're following the 2nd edition

*** Course Communication
- Everything on URCourses
  + Announcements
  + Assignments and Handin
  + Textbook, Slides, Videos
  + Email
  + Discussion Forum

- Do NOT ask programming/conceptual questions by email
  + Use the discussion forum
  + If you're wondering, others are too
  + EXCEPTION: when you can't ask your question without revealing
    your solution to the assignment

*** Grading Scheme
  + 25% assignments
  + 25% midterm
    - In-class
    - Thursday, July 25
  + 50% final
    - Aug 19
    - 2pm-5pm
    - This room
*** Assignments
- Six weekly assignments
- Due Tuesday at noon (11:59am)
  + No extensions
  + Lowest grade dropped
- Submitted over UR Courses
*** Assignments (ctd.)
- Mostly programming
  + Some conceptual questions
- Score based on running tests
  + Some public (included in assignment)
  + Some private (only known by me)
  + Code doesn't run $->$ no marks
- Some points for style/documentation/etc.
  +  Sample based marking
*** Attendance
- Attendance is mandatory but unenforced
  + Lecture contents is fair game for exams
- Lectures will contain walk-throughs of code
  and problem solving examples
- This is NOT a memorization-focused class
- I'll do my best to post slides and example code from lectures
  + But ultimately it's your responsibility to catch up on missed material
*** Office Hours :
- Mon 2:30-3:45pm
- Mon 4:30-5:15pm
- Wed 11:00am-11:45am
- Thurs 2:30-3:45pm
- RIC 317
  + Take the elevator to 3rd floor, then go straight across
*** LLM Policy
**** Use of ChatGPT, GitHub Copilot, or any other Large Language Model or Generative AI is forbidden when completing the assignments for this class
- Considered a violation of Academic Integrity
**** ChatGPT has trouble with Racket/plait
- Don't expect sympathy if you copy/paste code from an LLM that doesn't work
**** Don't set yourself up for failure on the exams
- Doing the assignments is the best way to study
** Motivation: Functional Programming
*** Programming in This Class
- In plait
  + i.e., "PLAI-typed"
- Plait is
  + a programming language
  + a library for the Racket programming language
- We'll learn more why this distinction is fuzzy
*** What is Racket
- A programming language for writing programming languages
- LISP-like
  - parentheses ~(((((((((())))))))))~
  - functions are values just like anything else
- Immutable: once a variable has a value, it never changes
  + Racket does let you mutate variables,
    but those parts of the language are *forbidden* in this class
    - Unless otherwise specified

*** Will I Ever Use Racket in Industry?
**** \qquad
*****   \centering\huge _No_
*****   \centering (probably)
*** Future Proofing
- Don't know what you'll use in industry in 10 years
  + If you know how languages work, you can learn /any/ language quickly
  + Racket is effective for learning how languages work

*** Language Trends (from Google Trends)

**** \colored{RoyalBlue}{Objective C} vs \colored{BrickRed}{Swift}
[[./img/objc_vs_swift.png]]

**** \colored{RoyalBlue}{C++} vs \colored{BrickRed}{Python}
[[./img/cpp_vs_python.png]]
*** Syntax Vs Semantics
- Semantics
  + What a program /means/
  + How a program behaves
- Different syntaxes can have identical semantics
- _Course goal:_ Learning to see past syntax and understand a program
  as its semantics
- Racket looks very different from other languages
  + Expressions, not statements
  + Recursion, not loops
  + Parentheses & functions, not operators
- Changes how you think about programs

*** Seeing Past Syntax
 By the end of the course, you should be able to look at these programs and intuitively
 know that they're doing the same thing:

**** CPP
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+latex: {\scriptsize
  #+begin_src C :exports code
  int pow (int x, int y){
    int ret = 1;
    for (int i = 0; i < y; i++){
      ret *= x;
    }
    return ret;
  }
  #+end_src
#+latex: }

**** Racket
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+latex: {\scriptsize
#+begin_src racket :exports code
(define (pow x y)
  (if
    (<= y 0)
    0
    (* x (pow x (- y 1)))))
#+end_src
#+latex: }



*** Functional Programming Going Mainstream?
- We're seeing more languages adopt functional features
- Anonymous functions/closures (lambda)
  + Python, Ruby, JS, PHP, Swift, Go, Rust, etc.

  + Added to C++11

  + Added in Java 8
  + Most language have some form of ~map~ to apply a function to each element of a list

- Sum types
  + Also called variants, algebraic datatypes
  + Perfect for syntax trees
  + Now in Python, Typescript, C++ (~std::variant~), Java (sealed interfaces), Rust (enums)

- Learning these features in Racket will help if/when they show up in other languages in the future


** Motivation: Interpreters
    
*** Importance of Programming Languages
- Interpreter: (Code , input) $\hookrightarrow$ (Output , effects)
  + Effects: write to disk, display pixels, etc
- You interact with a compiler or interpreter every time you:
  + Write a program
  + Run a program
    - Python, JavaScript, JVM all use some kind of interpreter
    - The CPU is just an interpreter for machine code

*** Programming Languages Aren't Magic
- Understanding how languages are implemented can help you understand your code
  + Why is it slow/fast
  + How to prevent/properly handle errors
  + How to know that it's doing what you think it does

*** Domain Specific Languages :noexport:
- Small language for a particular kind of task

*** Is this a hard course?
**** Why interpreters are hard
- By the end if this course, you will be able to write a program that is
  powerful enough to simulate every other computer program that ever has or
  ever will be written

**** Why interpreters are easy
- It's just a bunch of tree traversals


*** Intro

**** Questions?
* Functional Programming 1: Recursion and Immutable Data
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides002-plait.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

*** Overview
- Topic: Functional Programming in Racket and plait
- Required Reading:
  + Plait tutorial (URCourses)
- Optional Reference
  + Plait videos, HtDP videos
** Programming in CS 350
*** All coding for this class uses:
- The Racket Programming Language
- The ~plait~ library for Racket
- The Dr. Racket editor
** Racket
*** What is Racket?
- Lisp-style language
  + ~((((((((Parentheses))))))))~
- Language for making languages

*** What is Dr. Racket?
- IDE for Racket
  - Syntax highlighting
  - Other useful features
- Read-Eval-Print-Loop (REPL)
  + Feedback when writing code
  + Can  evaluate expressions while you're writing your code
- Other editors are possible
  + ... but you're on your own if you have problems
  + see https://docs.racket-lang.org/guide/other-editors.html

** Plait
*** What is Plait?
****  "PLAI-typed"
**** Language defined in Racket
- Racket functions you can call
- Adds syntax to Racket
  + Declaring and pattern matching on data types
  + Type annotations for functions
- Minimal
  + Has what you need to write programming languages
  + Not much else
  + You can do a lot with very little

*** Plait features:

- Type inference
  + Every expression is typed
  + Don't have to write down the types
- Algebraic Data Types



*** Parentheses
- Racket programs are trees called "S-expressions"
- Parentheses give this tree structure
- Default: parentheses mean function call
  + Racket writes ~(f x)~, not ~f(x)~
- ~x~ is not the same as ~(x)~
  + ~x~ gets the value of the variable ~x~
  + ~(x)~ is calling a function named ~x~ with zero arguments

*** Numbers

****   
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:

#+name: plait-numbers
#+begin_src racket :exports both
;;!!appear!!
;;!!results!!
(+ 2 7)
(- 10 0.5)
(* 1/3 2/3)
(/ 1 1000000000000.0)
(max 10 20)
(modulo 10 3)
#+end_src

****    
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:
#+BEGIN_EXPORT latex
\onslide<1->
#+END_EXPORT
#+RESULTS: plait-numbers


*** Booleans

****   
:PROPERTIES:
:BEAMER_COL: 0.68
:BEAMER_ENV: block
:END:

#+name: plait-booleans
#+begin_src racket :exports both
;;!!appear!!
;;!!results!!
(= (+ 2 3) 5)
(> (/ 0 1) 1)
(zero? (- (+ 1 2) (+ 3 0)))
(and (< 1 2) (> 1 0))
(or (zero? 1) (even? 3))
#+end_src

****    
:PROPERTIES:
:BEAMER_COL: 0.28
:BEAMER_ENV: block
:END:
#+BEGIN_EXPORT latex
\onslide<1->
#+END_EXPORT
#+RESULTS: plait-booleans


        
***  Conditionals
- Conditionals are *expressions*, not statements
- Boolean changes what the expression *is*, not what it does
#+begin_src racket :exports both
(if (< 2 3) "hello" "goodbye")
(+ 3
  (if (= 2 (+ 1 1))
      3
      40))
#+end_src

***  Functions
- Calling a function replaces variable with concrete argument
#+begin_src racket :exports both
(define (addOne [x : Number]) : Number
  (+ x 1))
(addOne 10)
#+end_src

***  Functions
#+begin_src racket :exports both
(define (isRemainder [x : Number]
                     [y : Number]
                     [remainder : Number])
        : Boolean
  (= remainder (modulo x y)))
(isRemainder 10 3 1)
(isRemainder 10 4 1)
#+end_src

***  Functions (ctd.)
- General form:

#+begin_src racket :exports code
(define (functionName
         [argName : argType]
         ...
         [argNameN : argTypeN]) : returnType
  functionBody)
#+end_src
- Later in the course we'll see another way of defining functions

*** Symbols
- Special type in Racket
- Written with single quote ~'a~, ~'hello~, ~'foo~
- Like strings, but you don't ever traverse/concatenate/look inside
- Only relevant operation is comparison
  + ~(symbol=? 'a 'b)~
  + Compares pointers, so very fast




*** Intermediate definitions
- Can still define variables
  + Once they're given a value, never changes
  + Allows re-use
    - Only evaluated once, can use multiple times
#+begin_src  racket :noweb strip-export :exports both
(define (squaredSum [x : Number]
                    [y : Number]) : Number
  (let ([xy (+ x y)])
    (* xy xy)))
(squaredSum 1 2)
#+end_src

#+RESULTS:
#+begin_src racket
9
#+end_src

*** Alternate Versions of Let
- ~let*~ : multiple definitions, later ones can refer to earlier ones
- 99% of the time this is what you want to use
  #+begin_src racket
    (let* ([x (+ 2 3)]
           [y (* x x)])
      (* y y))
  #+end_src


- ~letrec~ : multiple definitions that can all refer to each other
  + We'll see this later when we learn about lambdas
** Functional Thinking and Recursion

*** What Is Functional Programming?
- Functions in our program correspond to functions in math
  + Mapping from inputs to outputs
  + Same inputs always produce the same outputs
- Talk about what programs *are*, not what programs do
- Instead of changing variable values
  + We call functions with different arguments
- Instead of changing data structures
  + We decompose them, copy the parts, and reassemble them in new ways
  + Copying is implemented with pointers
    - Fast, memory efficient

*** Advantages of Functional Programming
- All program state is *explicit*
  + Easy to tell exactly what a function can change
  + No shared state between components
    - Other function can't change value without realizing
    - No data races for threading
- Programming is *declarative*
  + Structure of the problem guides structure of the solution
- Equational reasoning
  + In imperative languages, equals sign ~=~ is a LIE
    - Can write ~x = 3; x = 4;~, but ~3 != 4~
  + If have ~(define (f x) body)~, then for all ~y~,
    ~(f y)~ and ~body~ are interchangable
    - after replace ~x~ with ~y~ in ~body~
    - Easier to tell if your program is correct
    - Some optimizations easier
*** Disadvantages of Functional Programming
- None?
- Sometimes slower
  + Very hard to do without Garbage Collection
    - e.g. see Closures in Rust
  + Sometimes faster because you need fewer safety checks in your code
- Farther from what the CPU is actually doing
- Some algorithms are more concise with mutation
  + But lots aren't
*** How to design functional programs
**** 5 Step method:
1. Determine the *representation* of inputs and outputs
2. Write *examples* and tests
3. Create a *template* of the function
   - Depends on input/output types
   - Covers all cases
   - Possibly extracts fields, recursive calls, etc.
4. *Fill* in the holes in the template

5. *Run* tests

**** Further reference:
http://htdp.org, Matthew Flatt's Notes (URCourses)




*** Factorial - Representation
- $n! = 1 \times 2 \times \ldots n$
- Takes in a (natural) number, outputs a number
  #+begin_src racket
  (define (factorial [n : Number]) : Number
    (error 'factorial "TODO"))
  #+end_src


*** Factorial - Examples
  #+begin_src racket
   ;;!!appear!!

  (test (factorial 0) 1 )
  (test (factorial 1) 1 )
  (test (factorial 2) 2 )
  (test (factorial 3) 6 )
  (test (factorial 4) 24 )
  (test (factorial 5) 120 )
  #+end_src
- Notice the pattern?

*** Factorial - Template
- A natural number is either
  + Zero
  + One more than some other number
    - We call this the "successor", written "S" or "suc"
    - Probably want to use this in the solution
#+begin_src racket
(define (factorial [n : Number]) : Number
  (if (zero? n)
      (error 'zero "TODO")
      (let ([n-1 (- n 1)])
        (error 'suc "TODO"))
      ))
#+end_src


*** Factorial - Recursion
- Divide problem into base case and recursive cases
- Can use recursive calls to smaller arguments
- Build up solution in terms of solutions to smaller problems
#+begin_src racket
(define (factorial [n : Number]) : Number
  (if (zero? n)
      (error 'zero "TODO")
      (let*
          ([n-1 (- n 1)]
           [fn-1 (factorial n-1)])
          (error 'suc "TODO"))
      ))
#+end_src

*** Factorial - Filling holes
- Example gives the base case for 0
- Notice the pattern
  + Multiplying the first n numbers is the same as n times the first n-1 numbers
  + We get that from our recursive call
#+name: factorial-complete
#+begin_src racket
(define (factorial [n : Number]) : Number
  (if (zero? n)
      1
      (let*
          ([n-1 (- n 1)]
           [fn-1 (factorial n-1)])
          (* n fn-1))
      ))
#+end_src


*** Run Tests
#+begin_src racket :exports both :noweb strip-export
<<factorial-complete>>
(test (factorial 0) 1 )
(test (factorial 5) 120 )
#+end_src


*** Trust the Natural Recursion

- The magic key:
  + /Assume/ you have a solution already, but only for smaller arguments
  + Express solution for larger ones in terms of smaller ones
  + Like induction in math
- The shape of the data guided the shape of the solution
  + Zero had no sub-data, so there were no recursive calls
  + $suc\ n$ has one sub-value, namely $n$
    - One recursive call

*** Preconditions
- Note: types not quite precise enough
  + e.g. ~(factorial -1)~ or ~(factorial 1/2)~ loop forever
- Precondition: argument is a non-negative whole number
  + Can't express this in the code, so write in the comments
  + Aside: I research languages where you /can/ express this with types

*** Another Example: Exponentiation
+ Live coding in Dr. Racket



** Unbounded Data: Lists

*** Functional Linked Lists
- Every linked list is one of:
  + Empty (sometimes called ~nil~ or ~null~)
  + An element appended to the beginning of another list
- We call the operation of appending an element to a list ~cons~
  + Historical name, goes back to LISP days
- Cons does *not* change its input
  + Creates a new list whose tail is the old list

*** Lists in Racket
+ Multiple ways to write lists
+ ~'()~ is the empty list, can also write ~empty~
+ Extending lists:  ~(cons h t)~ creates list with element ~h~ appended to list ~t~
  - ~h~ and ~t~ for ~head~ and ~tail~
+ List literals, can write ~(list 1 2 3 4)~ or ~'(1 2 3 4)~
  - Shorthand for:
  - ~(cons 1 (cons 2 (cons 3 (cons 4 '()))))~
+ Lots more helper functions, see the documentation


*** Template for Lists
- Two cases: list is empty or cons
- Make a recursive call on tail of cons case
  #+begin_src racket
  (define (list-template
           [xs : (Listof Number)])
    (if (empty? xs)
        (error 'nil "TODO")
        (let ([h (first xs)]
              [t (rest xs)]
              [tRet (list-template t)])
          (error 'cons "TODO"))
        ))
  #+end_src

*** Example: Sum
#+begin_src racket :exports both
  (define (sum [xs : (Listof Number)])
    : Number
    (if (empty? xs)
        0
        (let* ([h (first xs)]
               [t (rest xs)]
               [tRet (sum t)])
          (+ h tRet))))
   (sum '())
   (sum '(1 2 3))
   (sum '(100 2 3))
#+end_src

#+RESULTS:
#+begin_src racket
0
6
#+end_src

*** Pattern Matching: Motivation
+ Recursive case: used "getter" function to get the sub-data in the recursive case
  - ~(- x 1)~ for numbers
  - ~first~ and ~rest~ for lists
+ Always want to have the sub-parts available
+ Don't want to apply getters on the wrong data
  - e.g. ~first '()~ will raise an error


*** Pattern Matching:


*** Example: Generating a Modified List
+ e.g. Increment each number in a list
  + Uses pattern matching
  + Shows how to create lists recursively
  #+begin_src racket :exports both
(define (increment [xs : (Listof Number)])
        : (Listof Number)
  (type-case (Listof Number) xs
    [empty
       empty]
    [(cons h t)
       (cons (+ h 1) (increment t))]))
(increment '(2 3 4))
  #+end_src



*** Parametric Polymorphism
+ Lists are a *parameterized type*
  - Only need to define once for the different element types
+ Many list functions are *polymorphic*
  - Work regardless of what type of elements there are
  - Types contain *type variables*, denoted with single quote ~'x~
    + Like symbols
  - Plait type inference figures out solutions for type variables when you call a function
  - E.g. ~first : ((Listof 'a) -> 'a)~
    + Input is list whose elements are some type ~'a~
    + Output has type ~'a~
    + e.g. ~first '(1 2 3)~ is a ~Number~, but ~first '(#t #f #t)~ is a Boolean
+ Later, this will be very useful for writing generic list operations

*** Example: List Concatenation
- We can combine two lists into a single list
- Polymorphic type
  + Works for list with any contents
  + We never do anything with the contents other than copy
  + This function is built into Plait as ~append~
    #+name: plait-concat-def
    #+begin_src racket :exports both
  (define (concat [xs : (Listof 'elem)]
                  [ys : (Listof 'elem)])
          : (Listof 'elem)
    (type-case (Listof 'elem) xs
      [empty
         ys]
      [(cons h t)
         (cons h (concat t ys))]))
    #+end_src

*** Example: List Concatenation (ctd.)
**** Example
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:
    #+name: plait-concat
    #+begin_src racket :exports both :noweb strip-export
  <<plait-concat-def>>
  ;;!!appear!!
  ;;!!results!!

  (concat '(1 2 3) '(4 5 6))
  (concat '("3" "5") '("0"))
  (concat '() '(#t))
  (concat '(#f) '())
    #+end_src

**** Results
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:
#+RESULTS: plait-concat


*** More Examples
- Demo: Dr. Racket (as time permits)
  + Duplicating each element of a list
  + "zipping" two lists together
  + Filtering out odd elements of a list


* Functional Programming 2: Defining Data Types
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides003-datatypes.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** Warmup: Pairs

*** Pairs: "AND" for types
-  ~(Number * Boolean)~
  + Cartesian product
    - "AND" for types
  + A value of this type contains a ~Number~ AND ~a Boolean~
  + Why is it infix? Who knows
    - Maybe to help distinguish it from multiplication
- Projections
  + Get the data from the pairs
#+begin_src racket :exports both
(define myPair : (Number * Boolean)
   (pair 2 #t))
(fst myPair) ;;Number
(snd myPair) ;;Boolean
#+end_src

#+RESULTS:
#+begin_src racket
2
#t
#+end_src
*** Pairs in General
- For any types ~'a~ and ~'b~ there is a type ~('a * 'b)~
- Build with ~pair : ('a 'b -> ('a * 'b))~
  + Takes one argument of each type, produces the pair
- Projections
  + ~fst : (('a * 'b) -> 'a)~
  + ~snd : (('a * 'b) -> 'b)~

** Algebraic Data Types

*** "OR" for types
- Pairs gave us "AND"
- What does "OR" look like for types?
  + ~(OR Number Boolean)~ should be the type of values that are either a number or a boolean
  + Want a tag so we can check which one it is
    - Called a "constructor"
    - not the same as Java/OOP constructor
- Saw some examples like this already
  + A number is zero OR one plus another number
  + A list is empty OR an element cons-ed to another list
- Racket lets us define our own types mixing AND and OR

*** First example

#+name: shape-defn
#+begin_src racket
(define-type Shape
  (Rectangle [length : Number]
             [width : Number])
  (Circle [radius : Number]))

(define tv (Rectangle 16 9))
(define loonie (Circle 1))
#+end_src
- ~Shape~ is a /datatype/
- It has two /constructors/, ~Rectangle~ and ~Circle~
  + i.e. a Shape is a circle or a rectangle
- ~Rectangle~ has two fields with type Number, ~length~ and ~width~
- ~Circle~ has one field with type Number

*** Creating values of a datatype
#+begin_src racket
(define-type Shape
  (Rectangle [length : Number]
             [width : Number])
  (Circle [radius : Number]))

(define tv (Rectangle 16 9))
(define loonie (Circle 1))
#+end_src
- We construct a Shape by calling a constructor
  + Doesn't *do* anything except package the data together
- A Shape either has two numbers OR one number
  + Depending on the tag
*** Auto-generated Functions
#+begin_src racket :noweb strip-export
<<shape-defn>>
(Rectangle? tv)
(Circle? tv)
(Rectangle-length tv)
;; (test/exn (Circle-radius tv) "")
  ;;raises an error, no such field present
#+end_src

#+RESULTS:
#+begin_src racket
#t
#f
16
#+end_src

*** Pattern matching
- Don't want to accidentally get a field that doesn't exist
- Almost always want to use the fields in the solution
- Solution: pattern-matching
#+begin_src racket :noweb strip-export :exports both
<<shape-defn>>
(define (area [shp : Shape]) : Number
  (type-case Shape shp
     [(Rectangle l w)
       (* l w)]
     [(Circle r)
       (* 3.14 (* r r))])
)
(area tv)
(area loonie)
#+end_src

#+RESULTS:
#+begin_src racket
144
3.14
#+end_src

*** Total Matching
- Missing a case in pattern matching is a /syntax error/
- Lets us know we are safe
- Can add an else clause to handle multiple cases
  + See Racket window
*** E.g. Representing Failure
+ In plait standard library
#+begin_src racket
(define-type (Optionof 'a)
  (none)
  (some [v : 'a]))
#+end_src
+ Pattern matching guarantees no null pointer errors
  - We'll see a more detailed example

*** Most Generic Form
#+begin_src racket
(define-type (Either 'a 'b)
  (Left [inLeft : 'a])
  (Right [inRight : 'b])
)
#+end_src
- You can define all (non-recursive) datatypes  with this and pairs
- e.g. Shape is ~(Either (Number * Number) Number)~

** Recursive Data

*** Self-reference in types
- The real power of datatypes is the ability to have fields of the type being defined
- This allows us to define *trees*
  + of arbitrary depth
- Data can be traversed using recursion


*** Example: Lists as a dataype
#+name: num-list
#+begin_src racket
(define-type NumList
  (Nil)
  (Cons [head : Number] [tail : NumList]))
#+end_src
- Note: this is not quite how lists are defined in Racket/plait
  + But they could be!
- Recursive fields in datatype $\to$ recursive calls in template
#+begin_src racket :noweb strip-export
<<num-list>>
(define (sum [xs : NumList])
  (type-case NumList xs
             [(Nil)
              0]
             [(Cons h t)
              (let ([sumRest (sum t)])
                    (+ h (sum t)))
              ]))
(sum (Cons 100 (Cons 20 (Cons 3 (Nil)))))
#+end_src

#+RESULTS:
#+begin_src racket
123
#+end_src

*** Example: Filesystem
+ Model of a file system
  - Not how is implemented on disk
#+name: fs-defn
#+begin_src racket
(define-type Filesystem
  (File [name : String]
        [data : Number])
  (Folder [name : String]
          [contents : (Listof Filesystem)]))
#+end_src

*** Linear Search using Recursion

- Find the first matching file
#+name: fs-search
#+begin_src racket :noweb strip-export

(define (search [target : String]
                [fs : Filesystem]) : (Optionof Number)
  (type-case Filesystem fs
             [(File name data)
              (if (string=? name target)
                  (some data)
                  (none))]
             [(Folder _ contents)
               (searchList target contents)]))
#+end_src

*** Helper Function: Searching the list
- We have mutually recursive types
  + ~Filesystem~ contains ~(Listof Filesystem)~
  + ~(Listof Filesystem)~ contains ~Filesystem~
- So we use mutually-recursive functions

#+name: fs-searchlist
#+begin_src racket

(define (searchList [target : String]
                    [files : (Listof Filesystem)])
        : (Optionof Number)
  (type-case (Listof Filesystem) files
             [empty (none)]
             [(cons h t)
              (let ([result (search target h)])
                (if (none? result)
                    (searchList target t)
                    result))
              ]))
#+end_src
*** Testing the search
#+begin_src racket :noweb strip-export :exports both
<<fs-defn>>
<<fs-search>>
<<fs-searchlist>>
(define InnerSolarSystem
  (Folder "Sun"
          (list (File "Mercury" 1)
                (File "Venus" 2)
                (Folder "EarthSystem"
                        (list (File "Earth" 3)
                              (File "Moon" 3.5)))
                (Folder "MarsSystem"
                        (list (File "Mars" 4)
                              (File "Phobos" 4.3)
                              (File "Diemos" 4.6))))))

(search "Moon" InnerSolarSystem)
(search "Jupiter" InnerSolarSystem)
#+end_src

#+RESULTS:
#+begin_src racket
(some 3.5)
(none)
#+end_src



* Abstract Syntax and Parsing
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides004-syntax.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** The Big Picture


*** Life of a program

- The Language Pipeline:

#+latex: {\tiny
#+ATTR_LATEX: :align p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}p{0.11\textwidth}
| Source code | $\xrightarrow{\text{parsing}}$ | Abstract syntax tree | $\xrightarrow{translation}$ | Core Syntax                | $\xrightarrow{evaluation}$  | Result              |
|             |                                |                      |                             |                            |                             |                     |
| \nohyphens{text file} | \nohyphens{lexing / tokenizing first} | \nohyphens{data structure } | \nohyphens{desugaring / compilation} | simpler AST / machine code | interpreter, execute on CPU | value, side effects |
|             |                                |                      |                             |                            |                             |                     |
#+latex: }



*** Syntax vs Semantics
- Can have many syntaxes that parse to the same abstract syntax
  + Different keywords
  + Different operator names
  + Different order of expressions
- E.g. plait vs shplait


** Describing Syntax

*** EBNF
- Extended Backus-Naur form
  + Named after scientists who worked on Algol

- Notation for Context Free Grammars
  + See CS 411

- Describes which strings are valid expressions/statements/etc. in a language

- Generative

  + Gives a process for generating valid strings in the language

  + String is valid if and only if it's generated by the grammar

*** Example
#+begin_src
<expr> ::=
    "{" "+" <expr> <expr> "}"
  | "{" "*" <expr> <expr> "}"
  | number
#+end_src
- ~<expr>~ is a /nonterminal/
  + A symbolic variable that doesn't show up in the final string, but is replaced using a rule
- ~::=~ means /can be one of/
- ~|~ separates the possibilities
- Literal strings are in quotation marks
  + Usually for keywords, operators or parentheses
- ~number~ is a literal number e.g. some sequence of digits

*** Generating a string
- Start with a single non-terminal
  + e.g. ~<expr>~ for an expression
- Until you have a string with no non-terminals, repeatedly:
  + Replace a non-terminal with one of its variants
    - i.e. one of the things on the right of ~::=~
- Examples:
  + ~<expr> -> 3~
  + ~<expr> -> {+ <expr> <expr>} -> {+ 2 <expr>} -> {+ 2 5}~
  + ~<expr>~
    - ~-> {* <expr> <expr>}~
    - ~-> {* {+ <expr> <expr>} <expr>}~
    - ~-> {* {+ 5 <expr>} <expr>}~
    - ~->{ * {+ 5 100000} <expr>}~
    - ~-> { * {+ 5 100000} -3}~

** Parsing and Abstract Syntax

*** Parse Trees
- Notice that the different replacements didn't affect each other
  + Can effectively replace them in parallel
- Tree structure
  + Non-terminal is a node
  + Terminal is a leaf
  + Edge is application of rule from grammar
- Can make a datatype representing these trees
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr]))
#+end_src

#+RESULTS:
#+begin_src racket
#+end_src

*** Abstract Syntax
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr]))
#+end_src
- This is called the /abstract syntax/ for the programming language
- A value of this type is called an /abstract syntax tree/
  + AST for short

*** Parsing
- The process of turning source code (linear string) into abstract syntax (tree)
  + Turns the program into a thing we process recursively
  + Tree structure mirrors structure of the program
- Can fail
  + What if the string isn't generated by the grammar?

*** Parsing in this class
- Parsing is an interesting problem
- But it's not an interesting /programming languages/ problem
- We will use Racket/plait features to do most of the parsing for us
  + Use  quoting to write s-expressions directly
    - Does the hard work of figuring out nested brackets

*** S-expressions
- Symbolic expressions
  + Goes back to John McCarthy, LISP, early days of AI at MIT
  + s-exp for short
- An S-expression is either
  + A symbol
  + A literal (number, boolean, string, etc.)
  + A bracketed list of S-expressions
- The backtick ~`~ in Racket says "interpret the next thing as an s-exp"
  + Single-quote ~'~ does the same but doesn't handle literals, just symbols
  #+begin_src racket
    `a
    `(+ 2 3)
    `(a b c d (+ 2 3) #t (#f #f))
  #+end_src

  #+RESULTS:
  #+begin_src racket
  `a
  `(+ 2 3)
  ~(a b c d (+ 2 3) #t (#f #f))
  #+end_src
- We'll use backtick as the first half of our parser
  + Easier to deal with s-expressions than strings
*** From S-exp to AST
- S-expression is a tree
  + Might not be a tree representing anything in our language
- If s-exp is literal
  + Generate the literal in our AST
  + Error if it's unsupported
- If it's a list
  + Check the first thing in the list
  + If it's an operation, check that we have the right number of arguments
  + If we do, (try to) parse each argument
- Otherwise, fail
- Uses the ~s-exp-match?~ function
  + Don't need to memorize how it works, we'll give you the parsers for the most part
*** Example Parser
#+name: arith-parse
#+begin_src racket
(define (parse [s : S-Exp]) : Expr
  (cond
    [(s-exp-match? `NUMBER s) (NumLit (s-exp->number s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (Plus (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (Times (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [else (error 'parse "invalid input")]))
#+end_src
* Arithmetic: Our First Interpreter
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides005-arith.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** Interpreters: Overview

*** The Church Turing Thesis

#+ATTR_LATEX: :align p{0.2\textwidth}p{0.2\textwidth}p{0.2\textwidth}p{0.2\textwidth}
|   | [[./img/Alonzo_church.jpg]]     | [[./img/goedel.jpg]]                        | [[./img/turing.jpg]]            |
|   | Alonzo Church                   | Kurt Gödel                                  | Alan Turing                     |
|   |                                 |                                             |                                 |
|   | /\nohyphens{(lambda calculus)}/ | /\nohyphens{(general recursive functions)}/ | /\nohyphens{(Turing machines)}/ |
|   |                                 |                                             |                                 |





*** The Church Turing Thesis
**** Turing Completeness
- The following can all simulate each other:
  + Turing Machines
  + General-recursive functions
  + Lambda calculus (we'll see later)
- We call a programming language that can simulate a Turing machine
  /Turing Complete/
  + Any language with ~while~ loops or recursion is Turing Complete
**** All Turing Complete Languages can simulate each other


*** Turing Completeness and Interpreters
- You can write an interpreter for any language in any Turing-complete language
- The features of a language you're interpreting are /completely unrelated/ to the features of the language the interpreter is written in
  +  Sometimes you can piggyback on the implementation language features, but that's a matter what's /convenient/, not what's /possible/

*** Keeping it all straight
- The implementation language is NOT the language you're interpreting
- In this class, the implementation language is Racket/plait
- We'll write interpreters for a bunch of small languages
  + We'll call them "Curly" because we write them with curly brackets
  + Write Curly programs in Racket files using quotation

*** General Form of an Interpreter
#+begin_src racket
(define (interp [e : Expr]
                [x : SomeContext]
                ...
                [y : OtherContext])
        : Value
  ....)
#+end_src
- ~Expr~ is the is the AST datatype for whatever language we're interpreting
- What the context arguments and ~Value~ datatype are depend on the language
  + Initially we have no context arguments, and ~Value~ is very simple
  + Will get more complicated as we go through the course

*** Our First Interpreter
#+name: arith-ast
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr]))
#+end_src
- Recursive function on structure of syntax
  + Base cases are literals, translate directly into values
  + Recursive cases are operations
    - Interpret sub-expressions recursively
    - Combine according to value version of the operation


*** Our First Interpreter
- Interpreting arithmetic, so values are just plait ~Number~

#+name: arith-interp
#+begin_src racket :noweb strip-export :exports both
<<arith-ast>>
<<arith-parse>>
(define (interp [e : Expr] ) : Number
  (type-case Expr e
             [(NumLit n) n]
             [(Plus l r)
                (+ (interp l) (interp r))]
             [(Times l r)
                (* (interp l) (interp r))]))
(define (eval s-exp) (interp (parse s-exp)))
(eval `3)
(eval `{+ 2 5})
(eval `{+ {* 1 {+ 2 1}} {+ {* 3 4} {* 0 1000000}}})
#+end_src

#+RESULTS: arith-interp
#+begin_src racket
3
7
15
#+end_src

*** Adding features
- Need to update
  + AST definition
  + Parser
  + Interpreter
- Example: ~{if0 cond x y}~
  + Evaluates to ~x~ if ~cond~ evaluates to ~0~
  + Evaluates to ~y~ if ~cond~ evaluates to anything else

*** Updating the dataype
#+name: arith-ast
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr]))
  ;;NEW
  (If0 [test : Expr]
       [thenBranch : Expr]
       [elseBranch : Expr])
#+end_src

*** Updating the parser
#+begin_src racket
    [(s-exp-match? `{if0 ANY ANY ANY} s)
     (If0 (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))
            (parse (fourth (s-exp->list s))]
#+end_src

*** Updating the interpreter
#+begin_src racket :noweb strip-export :exports both
(define (interp [e : Expr] ) : Number
  (type-case Expr e
             [(NumLit n) n]
             [(Plus l r)
                (+ (interp l) (interp r))]
             [(Times l r)
                (* (interp l) (interp r))])
  
             [(If0 test thenBranch elseBranch)
               (if (= 0 (interp test))
                 (interp thenBranch)
                 (interp elseBranch)
               )])
#+end_src
* Desugaring: Our First Elaborator
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides006-desugar.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Syntactic Sugar
*** What is syntactic sugar
- Some language features strictly increase the power of a language
  + Let you do things that can't be done any other way
- Some language features aren't strictly necessary, but are nice to have
  + Otherwise we'd just code in machine code/assembly all the time
- These "nice to haves" are called /syntactic sugar/
  + They "sweeten" the experience of programming
*** Desugaring
- When one feature can be expressed in terms of another, sometimes we implement it by /desugaring/
  + Translating the AST for a feature into other language features
- Desugared features: no case in the interpreter
  + Instead, translate to a smaller "core" AST type
  + Keeps the interpreter small, easier to maintain
- Have two types for AST
  + Surface AST
  + Core AST
*** Example: Subtraction
- We'll add subtraction to our language
  + /without changing the interpreter at all/
- Separate AST into surface and core AST
- Add translation from surface to core AST
*** Subtraction: Datatype
- First need the surface AST
#+begin_src racket
(define-type SurfaceExpr
  (SurfNumLit [n : Number])
  (SurfPlus [left : SurfaceExpr]
        [right : SurfaceExpr])
  (SurfTimes [left : SurfaceExpr]
         [right : SurfaceExpr])
  (SurfIf0 [test : SurfaceExpr]
       [thenBranch : SurfaceExpr]
       [elseBranch : SurfaceExpr])
  (SurfSub [left : SurfaceExpr]
       [right : SurfaceExpr]))
#+end_src
*** Subtraction: Parser Case
#+begin_src racket
(define (parse [s : S-Exp]) : SurfaceExpr
  ...
    [(s-exp-match? `{- ANY ANY} s)
     (SurfSub (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))])
#+end_src
*** Subtraction: Elaborator
- Define function that translates from ~SurfaceExpr~ to ~Expr~
#+begin_src racket
(define (elab [surf : SurfaceExpr]) : Expr
  (type-case SurfaceExpr surf
             [(SurfNumLit n) (NumLit n)]
             [(SurfPlus x y) (Plus x y)]
             [(SurfTimes x y) (Times x y)]
             [(SurfIf0 test thn els) (If0 test thn els)]
             ;; Sub isn't in our core syntax
             [(SurfSub x y) (Plus x (Times (NumLit -1) y))])
  )
#+end_src
*** Compilation vs. Elaboration vs. Desugaring
- Technically we just wrote our first compiler
  + Translated a small language into an even smaller one
- Compilation is just a bunch of desugaring passes
  + Simpler and simpler languages untill we have something simple enough for assembly code





* Functions, Variables and Substitution
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides007-subst.pdf
:header-args:racket: :results code :lang plait
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
** Overview: Functions
*** Adding functions to the language
- Want to be able to re-use code, compute in terms of variables
- Two new Curly features
- Function definitions
  + ~{define {f x} {+ x 3}}~
- Function calls
  + Sometimes called /function applications/
  + ~{f 10}~, produces ~13~
  + To start: single argument, inputs and outputs number
*** Syntax: Definitions
- New datatype for function definitions
#+begin_src racket
(define-type FunDef
  (mkFunDef [name : Symbol]
            [arg : Symbol]
            [body : Expr]))
#+end_src
*** Parser: Definitions
- New parser
  + Note: function definition is not an expression
  + Need to elaborate body after parsing
#+begin_src racket
(define (parse-fundef [s : S-Exp]) : FunDef
  (cond
    [(s-exp-match? `{define {SYMBOL SYMBOL} ANY} s)
     (mkFunDef
        (s-exp->symbol
           (first (s-exp->list (second (s-exp->list s)))))
         (s-exp->symbol
            (second (s-exp->list (second (s-exp->list s)))))
         (elab (parse (third (s-exp->list s)))))]
    [else (error 'parse-fundef "invalid input")]))
#+end_src
*** New Expression Syntax
- We need a way to:
  + Call a function
  + Refer to the parameter of a function inside its body
#+begin_src racket
(define-type Expr
  (NumLit [n : Number])
  (Plus [left : Expr]
        [right : Expr])
  (Times [left : Expr]
         [right : Expr])
  (If0 [test : Expr]
       [thenBranch : Expr]
       [elseBranch : Expr])
  (Var [x : Symbol])
  (FunCall [f : Symbol]
           [arg : Expr]))
#+end_src
- Also add variables and calls to surface syntax
*** Interpreting Variables
- What is the meaning of a variable in a program?
  + Variable is just a placeholder for whatever the value is given to the function
- Interpreting a variable is an *error*
  + Similar to "out of scope" or "undefined variable" errors
- Could statically check if variable was out of scope
  + Might do later in the course
*** Interpreting Function Calls
- Function call:
  + Looks up body of function
  + Replaces variable with value given
  + Evaluates the body after that replacement
- Interpreter needs context now
  + List of function definitions
    #+begin_src racket
     (define (interp [expr : Expr]
                     [defs : (Listof FunDef)]) : Number
       ....)
    #+end_src
**** How can we replace a variable

*** Substitution
- More recursion!
- Traverse the expression
* Local Variables :noexport:
Local Variables:
org-latex-packages-alist: nil
End:



